// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Proto_msg.Loc.proto

#ifndef PROTOBUF_INCLUDED_Proto_5fmsg_2eLoc_2eproto
#define PROTOBUF_INCLUDED_Proto_5fmsg_2eLoc_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Proto_5fmsg_2eLoc_2eproto 

namespace protobuf_Proto_5fmsg_2eLoc_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Proto_5fmsg_2eLoc_2eproto
namespace robosense {
namespace localization {
namespace Proto_msg {
class MsgHeader;
class MsgHeaderDefaultTypeInternal;
extern MsgHeaderDefaultTypeInternal _MsgHeader_default_instance_;
class PointXYZIT;
class PointXYZITDefaultTypeInternal;
extern PointXYZITDefaultTypeInternal _PointXYZIT_default_instance_;
class ProcessLidar;
class ProcessLidarDefaultTypeInternal;
extern ProcessLidarDefaultTypeInternal _ProcessLidar_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class Vector1d;
class Vector1dDefaultTypeInternal;
extern Vector1dDefaultTypeInternal _Vector1d_default_instance_;
class VehicleStateMsg;
class VehicleStateMsgDefaultTypeInternal;
extern VehicleStateMsgDefaultTypeInternal _VehicleStateMsg_default_instance_;
}  // namespace Proto_msg
}  // namespace localization
}  // namespace robosense
namespace google {
namespace protobuf {
template<> ::robosense::localization::Proto_msg::MsgHeader* Arena::CreateMaybeMessage<::robosense::localization::Proto_msg::MsgHeader>(Arena*);
template<> ::robosense::localization::Proto_msg::PointXYZIT* Arena::CreateMaybeMessage<::robosense::localization::Proto_msg::PointXYZIT>(Arena*);
template<> ::robosense::localization::Proto_msg::ProcessLidar* Arena::CreateMaybeMessage<::robosense::localization::Proto_msg::ProcessLidar>(Arena*);
template<> ::robosense::localization::Proto_msg::Status* Arena::CreateMaybeMessage<::robosense::localization::Proto_msg::Status>(Arena*);
template<> ::robosense::localization::Proto_msg::Vector1d* Arena::CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(Arena*);
template<> ::robosense::localization::Proto_msg::VehicleStateMsg* Arena::CreateMaybeMessage<::robosense::localization::Proto_msg::VehicleStateMsg>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace robosense {
namespace localization {
namespace Proto_msg {

// ===================================================================

class Vector1d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.localization.Proto_msg.Vector1d) */ {
 public:
  Vector1d();
  virtual ~Vector1d();

  Vector1d(const Vector1d& from);

  inline Vector1d& operator=(const Vector1d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector1d(Vector1d&& from) noexcept
    : Vector1d() {
    *this = ::std::move(from);
  }

  inline Vector1d& operator=(Vector1d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector1d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector1d* internal_default_instance() {
    return reinterpret_cast<const Vector1d*>(
               &_Vector1d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Vector1d* other);
  friend void swap(Vector1d& a, Vector1d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector1d* New() const final {
    return CreateMaybeMessage<Vector1d>(NULL);
  }

  Vector1d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector1d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector1d& from);
  void MergeFrom(const Vector1d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector1d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.localization.Proto_msg.Vector1d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > data_;
  friend struct ::protobuf_Proto_5fmsg_2eLoc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointXYZIT : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.localization.Proto_msg.PointXYZIT) */ {
 public:
  PointXYZIT();
  virtual ~PointXYZIT();

  PointXYZIT(const PointXYZIT& from);

  inline PointXYZIT& operator=(const PointXYZIT& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointXYZIT(PointXYZIT&& from) noexcept
    : PointXYZIT() {
    *this = ::std::move(from);
  }

  inline PointXYZIT& operator=(PointXYZIT&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointXYZIT& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointXYZIT* internal_default_instance() {
    return reinterpret_cast<const PointXYZIT*>(
               &_PointXYZIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PointXYZIT* other);
  friend void swap(PointXYZIT& a, PointXYZIT& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointXYZIT* New() const final {
    return CreateMaybeMessage<PointXYZIT>(NULL);
  }

  PointXYZIT* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointXYZIT>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointXYZIT& from);
  void MergeFrom(const PointXYZIT& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointXYZIT* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional uint32 intensity = 4;
  bool has_intensity() const;
  void clear_intensity();
  static const int kIntensityFieldNumber = 4;
  ::google::protobuf::uint32 intensity() const;
  void set_intensity(::google::protobuf::uint32 value);

  // optional double timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:robosense.localization.Proto_msg.PointXYZIT)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_intensity();
  void clear_has_intensity();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  ::google::protobuf::uint32 intensity_;
  double timestamp_;
  friend struct ::protobuf_Proto_5fmsg_2eLoc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.localization.Proto_msg.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(NULL);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 status_int = 1;
  bool has_status_int() const;
  void clear_status_int();
  static const int kStatusIntFieldNumber = 1;
  ::google::protobuf::uint32 status_int() const;
  void set_status_int(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robosense.localization.Proto_msg.Status)
 private:
  void set_has_status_int();
  void clear_has_status_int();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 status_int_;
  friend struct ::protobuf_Proto_5fmsg_2eLoc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcessLidar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.localization.Proto_msg.ProcessLidar) */ {
 public:
  ProcessLidar();
  virtual ~ProcessLidar();

  ProcessLidar(const ProcessLidar& from);

  inline ProcessLidar& operator=(const ProcessLidar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessLidar(ProcessLidar&& from) noexcept
    : ProcessLidar() {
    *this = ::std::move(from);
  }

  inline ProcessLidar& operator=(ProcessLidar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessLidar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessLidar* internal_default_instance() {
    return reinterpret_cast<const ProcessLidar*>(
               &_ProcessLidar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProcessLidar* other);
  friend void swap(ProcessLidar& a, ProcessLidar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessLidar* New() const final {
    return CreateMaybeMessage<ProcessLidar>(NULL);
  }

  ProcessLidar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcessLidar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcessLidar& from);
  void MergeFrom(const ProcessLidar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessLidar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robosense.localization.Proto_msg.PointXYZIT point = 12;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 12;
  ::robosense::localization::Proto_msg::PointXYZIT* mutable_point(int index);
  ::google::protobuf::RepeatedPtrField< ::robosense::localization::Proto_msg::PointXYZIT >*
      mutable_point();
  const ::robosense::localization::Proto_msg::PointXYZIT& point(int index) const;
  ::robosense::localization::Proto_msg::PointXYZIT* add_point();
  const ::google::protobuf::RepeatedPtrField< ::robosense::localization::Proto_msg::PointXYZIT >&
      point() const;

  // optional string parent_frame_id = 3;
  bool has_parent_frame_id() const;
  void clear_parent_frame_id();
  static const int kParentFrameIdFieldNumber = 3;
  const ::std::string& parent_frame_id() const;
  void set_parent_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_frame_id(::std::string&& value);
  #endif
  void set_parent_frame_id(const char* value);
  void set_parent_frame_id(const char* value, size_t size);
  ::std::string* mutable_parent_frame_id();
  ::std::string* release_parent_frame_id();
  void set_allocated_parent_frame_id(::std::string* parent_frame_id);

  // optional string frame_id = 4;
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 4;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // optional string lidar_mode = 5;
  bool has_lidar_mode() const;
  void clear_lidar_mode();
  static const int kLidarModeFieldNumber = 5;
  const ::std::string& lidar_mode() const;
  void set_lidar_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_lidar_mode(::std::string&& value);
  #endif
  void set_lidar_mode(const char* value);
  void set_lidar_mode(const char* value, size_t size);
  ::std::string* mutable_lidar_mode();
  ::std::string* release_lidar_mode();
  void set_allocated_lidar_mode(::std::string* lidar_mode);

  // optional string points_type = 6;
  bool has_points_type() const;
  void clear_points_type();
  static const int kPointsTypeFieldNumber = 6;
  const ::std::string& points_type() const;
  void set_points_type(const ::std::string& value);
  #if LANG_CXX11
  void set_points_type(::std::string&& value);
  #endif
  void set_points_type(const char* value);
  void set_points_type(const char* value, size_t size);
  ::std::string* mutable_points_type();
  ::std::string* release_points_type();
  void set_allocated_points_type(::std::string* points_type);

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // optional uint32 seq = 2;
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::uint32 seq() const;
  void set_seq(::google::protobuf::uint32 value);

  // optional uint32 height = 7;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 7;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // optional uint32 width = 8;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 8;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional bool is_dense = 9;
  bool has_is_dense() const;
  void clear_is_dense();
  static const int kIsDenseFieldNumber = 9;
  bool is_dense() const;
  void set_is_dense(bool value);

  // optional bool is_transform = 10;
  bool has_is_transform() const;
  void clear_is_transform();
  static const int kIsTransformFieldNumber = 10;
  bool is_transform() const;
  void set_is_transform(bool value);

  // optional bool is_motion_correct = 11;
  bool has_is_motion_correct() const;
  void clear_is_motion_correct();
  static const int kIsMotionCorrectFieldNumber = 11;
  bool is_motion_correct() const;
  void set_is_motion_correct(bool value);

  // @@protoc_insertion_point(class_scope:robosense.localization.Proto_msg.ProcessLidar)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_seq();
  void clear_has_seq();
  void set_has_parent_frame_id();
  void clear_has_parent_frame_id();
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_lidar_mode();
  void clear_has_lidar_mode();
  void set_has_points_type();
  void clear_has_points_type();
  void set_has_height();
  void clear_has_height();
  void set_has_width();
  void clear_has_width();
  void set_has_is_dense();
  void clear_has_is_dense();
  void set_has_is_transform();
  void clear_has_is_transform();
  void set_has_is_motion_correct();
  void clear_has_is_motion_correct();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::robosense::localization::Proto_msg::PointXYZIT > point_;
  ::google::protobuf::internal::ArenaStringPtr parent_frame_id_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::internal::ArenaStringPtr lidar_mode_;
  ::google::protobuf::internal::ArenaStringPtr points_type_;
  double timestamp_;
  ::google::protobuf::uint32 seq_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 width_;
  bool is_dense_;
  bool is_transform_;
  bool is_motion_correct_;
  friend struct ::protobuf_Proto_5fmsg_2eLoc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleStateMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.localization.Proto_msg.VehicleStateMsg) */ {
 public:
  VehicleStateMsg();
  virtual ~VehicleStateMsg();

  VehicleStateMsg(const VehicleStateMsg& from);

  inline VehicleStateMsg& operator=(const VehicleStateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleStateMsg(VehicleStateMsg&& from) noexcept
    : VehicleStateMsg() {
    *this = ::std::move(from);
  }

  inline VehicleStateMsg& operator=(VehicleStateMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleStateMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleStateMsg* internal_default_instance() {
    return reinterpret_cast<const VehicleStateMsg*>(
               &_VehicleStateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(VehicleStateMsg* other);
  friend void swap(VehicleStateMsg& a, VehicleStateMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleStateMsg* New() const final {
    return CreateMaybeMessage<VehicleStateMsg>(NULL);
  }

  VehicleStateMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleStateMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleStateMsg& from);
  void MergeFrom(const VehicleStateMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleStateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string frame_id = 3;
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 3;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // optional string parent_frame_id = 4;
  bool has_parent_frame_id() const;
  void clear_parent_frame_id();
  static const int kParentFrameIdFieldNumber = 4;
  const ::std::string& parent_frame_id() const;
  void set_parent_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_frame_id(::std::string&& value);
  #endif
  void set_parent_frame_id(const char* value);
  void set_parent_frame_id(const char* value, size_t size);
  ::std::string* mutable_parent_frame_id();
  ::std::string* release_parent_frame_id();
  void set_allocated_parent_frame_id(::std::string* parent_frame_id);

  // optional .robosense.localization.Proto_msg.Vector1d origin = 6;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 6;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_origin() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& origin() const;
  ::robosense::localization::Proto_msg::Vector1d* release_origin();
  ::robosense::localization::Proto_msg::Vector1d* mutable_origin();
  void set_allocated_origin(::robosense::localization::Proto_msg::Vector1d* origin);

  // optional .robosense.localization.Proto_msg.Vector1d fix = 7;
  bool has_fix() const;
  void clear_fix();
  static const int kFixFieldNumber = 7;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_fix() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& fix() const;
  ::robosense::localization::Proto_msg::Vector1d* release_fix();
  ::robosense::localization::Proto_msg::Vector1d* mutable_fix();
  void set_allocated_fix(::robosense::localization::Proto_msg::Vector1d* fix);

  // optional .robosense.localization.Proto_msg.Vector1d pos = 8;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 8;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_pos() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& pos() const;
  ::robosense::localization::Proto_msg::Vector1d* release_pos();
  ::robosense::localization::Proto_msg::Vector1d* mutable_pos();
  void set_allocated_pos(::robosense::localization::Proto_msg::Vector1d* pos);

  // optional .robosense.localization.Proto_msg.Vector1d pos_cov = 9;
  bool has_pos_cov() const;
  void clear_pos_cov();
  static const int kPosCovFieldNumber = 9;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_pos_cov() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& pos_cov() const;
  ::robosense::localization::Proto_msg::Vector1d* release_pos_cov();
  ::robosense::localization::Proto_msg::Vector1d* mutable_pos_cov();
  void set_allocated_pos_cov(::robosense::localization::Proto_msg::Vector1d* pos_cov);

  // optional .robosense.localization.Proto_msg.Vector1d orien = 10;
  bool has_orien() const;
  void clear_orien();
  static const int kOrienFieldNumber = 10;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_orien() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& orien() const;
  ::robosense::localization::Proto_msg::Vector1d* release_orien();
  ::robosense::localization::Proto_msg::Vector1d* mutable_orien();
  void set_allocated_orien(::robosense::localization::Proto_msg::Vector1d* orien);

  // optional .robosense.localization.Proto_msg.Vector1d orien_cov = 11;
  bool has_orien_cov() const;
  void clear_orien_cov();
  static const int kOrienCovFieldNumber = 11;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_orien_cov() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& orien_cov() const;
  ::robosense::localization::Proto_msg::Vector1d* release_orien_cov();
  ::robosense::localization::Proto_msg::Vector1d* mutable_orien_cov();
  void set_allocated_orien_cov(::robosense::localization::Proto_msg::Vector1d* orien_cov);

  // optional .robosense.localization.Proto_msg.Vector1d angular_vel = 12;
  bool has_angular_vel() const;
  void clear_angular_vel();
  static const int kAngularVelFieldNumber = 12;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_angular_vel() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& angular_vel() const;
  ::robosense::localization::Proto_msg::Vector1d* release_angular_vel();
  ::robosense::localization::Proto_msg::Vector1d* mutable_angular_vel();
  void set_allocated_angular_vel(::robosense::localization::Proto_msg::Vector1d* angular_vel);

  // optional .robosense.localization.Proto_msg.Vector1d angular_vel_cov = 13;
  bool has_angular_vel_cov() const;
  void clear_angular_vel_cov();
  static const int kAngularVelCovFieldNumber = 13;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_angular_vel_cov() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& angular_vel_cov() const;
  ::robosense::localization::Proto_msg::Vector1d* release_angular_vel_cov();
  ::robosense::localization::Proto_msg::Vector1d* mutable_angular_vel_cov();
  void set_allocated_angular_vel_cov(::robosense::localization::Proto_msg::Vector1d* angular_vel_cov);

  // optional .robosense.localization.Proto_msg.Vector1d linear_vel = 14;
  bool has_linear_vel() const;
  void clear_linear_vel();
  static const int kLinearVelFieldNumber = 14;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_linear_vel() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& linear_vel() const;
  ::robosense::localization::Proto_msg::Vector1d* release_linear_vel();
  ::robosense::localization::Proto_msg::Vector1d* mutable_linear_vel();
  void set_allocated_linear_vel(::robosense::localization::Proto_msg::Vector1d* linear_vel);

  // optional .robosense.localization.Proto_msg.Vector1d linear_vel_cov = 15;
  bool has_linear_vel_cov() const;
  void clear_linear_vel_cov();
  static const int kLinearVelCovFieldNumber = 15;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_linear_vel_cov() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& linear_vel_cov() const;
  ::robosense::localization::Proto_msg::Vector1d* release_linear_vel_cov();
  ::robosense::localization::Proto_msg::Vector1d* mutable_linear_vel_cov();
  void set_allocated_linear_vel_cov(::robosense::localization::Proto_msg::Vector1d* linear_vel_cov);

  // optional .robosense.localization.Proto_msg.Vector1d acc = 16;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 16;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_acc() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& acc() const;
  ::robosense::localization::Proto_msg::Vector1d* release_acc();
  ::robosense::localization::Proto_msg::Vector1d* mutable_acc();
  void set_allocated_acc(::robosense::localization::Proto_msg::Vector1d* acc);

  // optional .robosense.localization.Proto_msg.Vector1d acc_cov = 17;
  bool has_acc_cov() const;
  void clear_acc_cov();
  static const int kAccCovFieldNumber = 17;
  private:
  const ::robosense::localization::Proto_msg::Vector1d& _internal_acc_cov() const;
  public:
  const ::robosense::localization::Proto_msg::Vector1d& acc_cov() const;
  ::robosense::localization::Proto_msg::Vector1d* release_acc_cov();
  ::robosense::localization::Proto_msg::Vector1d* mutable_acc_cov();
  void set_allocated_acc_cov(::robosense::localization::Proto_msg::Vector1d* acc_cov);

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // optional uint32 seq = 2;
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::uint32 seq() const;
  void set_seq(::google::protobuf::uint32 value);

  // optional uint32 status = 5;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robosense.localization.Proto_msg.VehicleStateMsg)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_seq();
  void clear_has_seq();
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_parent_frame_id();
  void clear_has_parent_frame_id();
  void set_has_status();
  void clear_has_status();
  void set_has_origin();
  void clear_has_origin();
  void set_has_fix();
  void clear_has_fix();
  void set_has_pos();
  void clear_has_pos();
  void set_has_pos_cov();
  void clear_has_pos_cov();
  void set_has_orien();
  void clear_has_orien();
  void set_has_orien_cov();
  void clear_has_orien_cov();
  void set_has_angular_vel();
  void clear_has_angular_vel();
  void set_has_angular_vel_cov();
  void clear_has_angular_vel_cov();
  void set_has_linear_vel();
  void clear_has_linear_vel();
  void set_has_linear_vel_cov();
  void clear_has_linear_vel_cov();
  void set_has_acc();
  void clear_has_acc();
  void set_has_acc_cov();
  void clear_has_acc_cov();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::internal::ArenaStringPtr parent_frame_id_;
  ::robosense::localization::Proto_msg::Vector1d* origin_;
  ::robosense::localization::Proto_msg::Vector1d* fix_;
  ::robosense::localization::Proto_msg::Vector1d* pos_;
  ::robosense::localization::Proto_msg::Vector1d* pos_cov_;
  ::robosense::localization::Proto_msg::Vector1d* orien_;
  ::robosense::localization::Proto_msg::Vector1d* orien_cov_;
  ::robosense::localization::Proto_msg::Vector1d* angular_vel_;
  ::robosense::localization::Proto_msg::Vector1d* angular_vel_cov_;
  ::robosense::localization::Proto_msg::Vector1d* linear_vel_;
  ::robosense::localization::Proto_msg::Vector1d* linear_vel_cov_;
  ::robosense::localization::Proto_msg::Vector1d* acc_;
  ::robosense::localization::Proto_msg::Vector1d* acc_cov_;
  double timestamp_;
  ::google::protobuf::uint32 seq_;
  ::google::protobuf::uint32 status_;
  friend struct ::protobuf_Proto_5fmsg_2eLoc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.localization.Proto_msg.MsgHeader) */ {
 public:
  MsgHeader();
  virtual ~MsgHeader();

  MsgHeader(const MsgHeader& from);

  inline MsgHeader& operator=(const MsgHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgHeader(MsgHeader&& from) noexcept
    : MsgHeader() {
    *this = ::std::move(from);
  }

  inline MsgHeader& operator=(MsgHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgHeader* internal_default_instance() {
    return reinterpret_cast<const MsgHeader*>(
               &_MsgHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MsgHeader* other);
  friend void swap(MsgHeader& a, MsgHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgHeader* New() const final {
    return CreateMaybeMessage<MsgHeader>(NULL);
  }

  MsgHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MsgHeader& from);
  void MergeFrom(const MsgHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double msgTimestamps = 1;
  bool has_msgtimestamps() const;
  void clear_msgtimestamps();
  static const int kMsgTimestampsFieldNumber = 1;
  double msgtimestamps() const;
  void set_msgtimestamps(double value);

  // optional uint32 msgVersion = 2;
  bool has_msgversion() const;
  void clear_msgversion();
  static const int kMsgVersionFieldNumber = 2;
  ::google::protobuf::uint32 msgversion() const;
  void set_msgversion(::google::protobuf::uint32 value);

  // optional uint32 msgType = 3;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 3;
  ::google::protobuf::uint32 msgtype() const;
  void set_msgtype(::google::protobuf::uint32 value);

  // optional uint32 deviceId = 4;
  bool has_deviceid() const;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 4;
  ::google::protobuf::uint32 deviceid() const;
  void set_deviceid(::google::protobuf::uint32 value);

  // optional uint32 msgFrameId = 5;
  bool has_msgframeid() const;
  void clear_msgframeid();
  static const int kMsgFrameIdFieldNumber = 5;
  ::google::protobuf::uint32 msgframeid() const;
  void set_msgframeid(::google::protobuf::uint32 value);

  // optional uint32 msgTotalCnt = 6;
  bool has_msgtotalcnt() const;
  void clear_msgtotalcnt();
  static const int kMsgTotalCntFieldNumber = 6;
  ::google::protobuf::uint32 msgtotalcnt() const;
  void set_msgtotalcnt(::google::protobuf::uint32 value);

  // optional uint32 msgLocalCnt = 7;
  bool has_msglocalcnt() const;
  void clear_msglocalcnt();
  static const int kMsgLocalCntFieldNumber = 7;
  ::google::protobuf::uint32 msglocalcnt() const;
  void set_msglocalcnt(::google::protobuf::uint32 value);

  // optional uint32 msgLocalLen = 8;
  bool has_msglocallen() const;
  void clear_msglocallen();
  static const int kMsgLocalLenFieldNumber = 8;
  ::google::protobuf::uint32 msglocallen() const;
  void set_msglocallen(::google::protobuf::uint32 value);

  // optional uint32 msgIndex = 9;
  bool has_msgindex() const;
  void clear_msgindex();
  static const int kMsgIndexFieldNumber = 9;
  ::google::protobuf::uint32 msgindex() const;
  void set_msgindex(::google::protobuf::uint32 value);

  // optional uint32 msgTotalFragment = 10;
  bool has_msgtotalfragment() const;
  void clear_msgtotalfragment();
  static const int kMsgTotalFragmentFieldNumber = 10;
  ::google::protobuf::uint32 msgtotalfragment() const;
  void set_msgtotalfragment(::google::protobuf::uint32 value);

  // optional uint32 msgFragmentIndex = 11;
  bool has_msgfragmentindex() const;
  void clear_msgfragmentindex();
  static const int kMsgFragmentIndexFieldNumber = 11;
  ::google::protobuf::uint32 msgfragmentindex() const;
  void set_msgfragmentindex(::google::protobuf::uint32 value);

  // optional uint32 msgRes0 = 12;
  bool has_msgres0() const;
  void clear_msgres0();
  static const int kMsgRes0FieldNumber = 12;
  ::google::protobuf::uint32 msgres0() const;
  void set_msgres0(::google::protobuf::uint32 value);

  // optional uint32 msgCheck16 = 13;
  bool has_msgcheck16() const;
  void clear_msgcheck16();
  static const int kMsgCheck16FieldNumber = 13;
  ::google::protobuf::uint32 msgcheck16() const;
  void set_msgcheck16(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robosense.localization.Proto_msg.MsgHeader)
 private:
  void set_has_msgtimestamps();
  void clear_has_msgtimestamps();
  void set_has_msgversion();
  void clear_has_msgversion();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_deviceid();
  void clear_has_deviceid();
  void set_has_msgframeid();
  void clear_has_msgframeid();
  void set_has_msgtotalcnt();
  void clear_has_msgtotalcnt();
  void set_has_msglocalcnt();
  void clear_has_msglocalcnt();
  void set_has_msglocallen();
  void clear_has_msglocallen();
  void set_has_msgindex();
  void clear_has_msgindex();
  void set_has_msgtotalfragment();
  void clear_has_msgtotalfragment();
  void set_has_msgfragmentindex();
  void clear_has_msgfragmentindex();
  void set_has_msgres0();
  void clear_has_msgres0();
  void set_has_msgcheck16();
  void clear_has_msgcheck16();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double msgtimestamps_;
  ::google::protobuf::uint32 msgversion_;
  ::google::protobuf::uint32 msgtype_;
  ::google::protobuf::uint32 deviceid_;
  ::google::protobuf::uint32 msgframeid_;
  ::google::protobuf::uint32 msgtotalcnt_;
  ::google::protobuf::uint32 msglocalcnt_;
  ::google::protobuf::uint32 msglocallen_;
  ::google::protobuf::uint32 msgindex_;
  ::google::protobuf::uint32 msgtotalfragment_;
  ::google::protobuf::uint32 msgfragmentindex_;
  ::google::protobuf::uint32 msgres0_;
  ::google::protobuf::uint32 msgcheck16_;
  friend struct ::protobuf_Proto_5fmsg_2eLoc_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector1d

// repeated double data = 1;
inline int Vector1d::data_size() const {
  return data_.size();
}
inline void Vector1d::clear_data() {
  data_.Clear();
}
inline double Vector1d::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.Vector1d.data)
  return data_.Get(index);
}
inline void Vector1d::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.Vector1d.data)
}
inline void Vector1d::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.localization.Proto_msg.Vector1d.data)
}
inline const ::google::protobuf::RepeatedField< double >&
Vector1d::data() const {
  // @@protoc_insertion_point(field_list:robosense.localization.Proto_msg.Vector1d.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
Vector1d::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.localization.Proto_msg.Vector1d.data)
  return &data_;
}

// -------------------------------------------------------------------

// PointXYZIT

// optional float x = 1;
inline bool PointXYZIT::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointXYZIT::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointXYZIT::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointXYZIT::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointXYZIT::x() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.PointXYZIT.x)
  return x_;
}
inline void PointXYZIT::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.PointXYZIT.x)
}

// optional float y = 2;
inline bool PointXYZIT::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointXYZIT::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointXYZIT::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointXYZIT::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointXYZIT::y() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.PointXYZIT.y)
  return y_;
}
inline void PointXYZIT::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.PointXYZIT.y)
}

// optional float z = 3;
inline bool PointXYZIT::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointXYZIT::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointXYZIT::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointXYZIT::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PointXYZIT::z() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.PointXYZIT.z)
  return z_;
}
inline void PointXYZIT::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.PointXYZIT.z)
}

// optional uint32 intensity = 4;
inline bool PointXYZIT::has_intensity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointXYZIT::set_has_intensity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointXYZIT::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointXYZIT::clear_intensity() {
  intensity_ = 0u;
  clear_has_intensity();
}
inline ::google::protobuf::uint32 PointXYZIT::intensity() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.PointXYZIT.intensity)
  return intensity_;
}
inline void PointXYZIT::set_intensity(::google::protobuf::uint32 value) {
  set_has_intensity();
  intensity_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.PointXYZIT.intensity)
}

// optional double timestamp = 5;
inline bool PointXYZIT::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PointXYZIT::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PointXYZIT::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PointXYZIT::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double PointXYZIT::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.PointXYZIT.timestamp)
  return timestamp_;
}
inline void PointXYZIT::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.PointXYZIT.timestamp)
}

// -------------------------------------------------------------------

// Status

// optional uint32 status_int = 1;
inline bool Status::has_status_int() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_status_int() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_status_int() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_status_int() {
  status_int_ = 0u;
  clear_has_status_int();
}
inline ::google::protobuf::uint32 Status::status_int() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.Status.status_int)
  return status_int_;
}
inline void Status::set_status_int(::google::protobuf::uint32 value) {
  set_has_status_int();
  status_int_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.Status.status_int)
}

// -------------------------------------------------------------------

// ProcessLidar

// optional double timestamp = 1;
inline bool ProcessLidar::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessLidar::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessLidar::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessLidar::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ProcessLidar::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.timestamp)
  return timestamp_;
}
inline void ProcessLidar::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.timestamp)
}

// optional uint32 seq = 2;
inline bool ProcessLidar::has_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProcessLidar::set_has_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProcessLidar::clear_has_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProcessLidar::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 ProcessLidar::seq() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.seq)
  return seq_;
}
inline void ProcessLidar::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.seq)
}

// optional string parent_frame_id = 3;
inline bool ProcessLidar::has_parent_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessLidar::set_has_parent_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessLidar::clear_has_parent_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessLidar::clear_parent_frame_id() {
  parent_frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_frame_id();
}
inline const ::std::string& ProcessLidar::parent_frame_id() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
  return parent_frame_id_.GetNoArena();
}
inline void ProcessLidar::set_parent_frame_id(const ::std::string& value) {
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
}
#if LANG_CXX11
inline void ProcessLidar::set_parent_frame_id(::std::string&& value) {
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
}
#endif
inline void ProcessLidar::set_parent_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
}
inline void ProcessLidar::set_parent_frame_id(const char* value, size_t size) {
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
}
inline ::std::string* ProcessLidar::mutable_parent_frame_id() {
  set_has_parent_frame_id();
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
  return parent_frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessLidar::release_parent_frame_id() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
  if (!has_parent_frame_id()) {
    return NULL;
  }
  clear_has_parent_frame_id();
  return parent_frame_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessLidar::set_allocated_parent_frame_id(::std::string* parent_frame_id) {
  if (parent_frame_id != NULL) {
    set_has_parent_frame_id();
  } else {
    clear_has_parent_frame_id();
  }
  parent_frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_frame_id);
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.ProcessLidar.parent_frame_id)
}

// optional string frame_id = 4;
inline bool ProcessLidar::has_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessLidar::set_has_frame_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessLidar::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessLidar::clear_frame_id() {
  frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_frame_id();
}
inline const ::std::string& ProcessLidar::frame_id() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.frame_id)
  return frame_id_.GetNoArena();
}
inline void ProcessLidar::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.frame_id)
}
#if LANG_CXX11
inline void ProcessLidar::set_frame_id(::std::string&& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robosense.localization.Proto_msg.ProcessLidar.frame_id)
}
#endif
inline void ProcessLidar::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robosense.localization.Proto_msg.ProcessLidar.frame_id)
}
inline void ProcessLidar::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robosense.localization.Proto_msg.ProcessLidar.frame_id)
}
inline ::std::string* ProcessLidar::mutable_frame_id() {
  set_has_frame_id();
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.ProcessLidar.frame_id)
  return frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessLidar::release_frame_id() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.ProcessLidar.frame_id)
  if (!has_frame_id()) {
    return NULL;
  }
  clear_has_frame_id();
  return frame_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessLidar::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
  frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.ProcessLidar.frame_id)
}

// optional string lidar_mode = 5;
inline bool ProcessLidar::has_lidar_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessLidar::set_has_lidar_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessLidar::clear_has_lidar_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessLidar::clear_lidar_mode() {
  lidar_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lidar_mode();
}
inline const ::std::string& ProcessLidar::lidar_mode() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
  return lidar_mode_.GetNoArena();
}
inline void ProcessLidar::set_lidar_mode(const ::std::string& value) {
  set_has_lidar_mode();
  lidar_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
}
#if LANG_CXX11
inline void ProcessLidar::set_lidar_mode(::std::string&& value) {
  set_has_lidar_mode();
  lidar_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
}
#endif
inline void ProcessLidar::set_lidar_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lidar_mode();
  lidar_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
}
inline void ProcessLidar::set_lidar_mode(const char* value, size_t size) {
  set_has_lidar_mode();
  lidar_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
}
inline ::std::string* ProcessLidar::mutable_lidar_mode() {
  set_has_lidar_mode();
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
  return lidar_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessLidar::release_lidar_mode() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
  if (!has_lidar_mode()) {
    return NULL;
  }
  clear_has_lidar_mode();
  return lidar_mode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessLidar::set_allocated_lidar_mode(::std::string* lidar_mode) {
  if (lidar_mode != NULL) {
    set_has_lidar_mode();
  } else {
    clear_has_lidar_mode();
  }
  lidar_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lidar_mode);
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.ProcessLidar.lidar_mode)
}

// optional string points_type = 6;
inline bool ProcessLidar::has_points_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessLidar::set_has_points_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessLidar::clear_has_points_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessLidar::clear_points_type() {
  points_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_points_type();
}
inline const ::std::string& ProcessLidar::points_type() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.points_type)
  return points_type_.GetNoArena();
}
inline void ProcessLidar::set_points_type(const ::std::string& value) {
  set_has_points_type();
  points_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.points_type)
}
#if LANG_CXX11
inline void ProcessLidar::set_points_type(::std::string&& value) {
  set_has_points_type();
  points_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robosense.localization.Proto_msg.ProcessLidar.points_type)
}
#endif
inline void ProcessLidar::set_points_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_points_type();
  points_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robosense.localization.Proto_msg.ProcessLidar.points_type)
}
inline void ProcessLidar::set_points_type(const char* value, size_t size) {
  set_has_points_type();
  points_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robosense.localization.Proto_msg.ProcessLidar.points_type)
}
inline ::std::string* ProcessLidar::mutable_points_type() {
  set_has_points_type();
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.ProcessLidar.points_type)
  return points_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessLidar::release_points_type() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.ProcessLidar.points_type)
  if (!has_points_type()) {
    return NULL;
  }
  clear_has_points_type();
  return points_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessLidar::set_allocated_points_type(::std::string* points_type) {
  if (points_type != NULL) {
    set_has_points_type();
  } else {
    clear_has_points_type();
  }
  points_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), points_type);
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.ProcessLidar.points_type)
}

// optional uint32 height = 7;
inline bool ProcessLidar::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProcessLidar::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProcessLidar::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProcessLidar::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 ProcessLidar::height() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.height)
  return height_;
}
inline void ProcessLidar::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.height)
}

// optional uint32 width = 8;
inline bool ProcessLidar::has_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProcessLidar::set_has_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProcessLidar::clear_has_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProcessLidar::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 ProcessLidar::width() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.width)
  return width_;
}
inline void ProcessLidar::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.width)
}

// optional bool is_dense = 9;
inline bool ProcessLidar::has_is_dense() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProcessLidar::set_has_is_dense() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProcessLidar::clear_has_is_dense() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProcessLidar::clear_is_dense() {
  is_dense_ = false;
  clear_has_is_dense();
}
inline bool ProcessLidar::is_dense() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.is_dense)
  return is_dense_;
}
inline void ProcessLidar::set_is_dense(bool value) {
  set_has_is_dense();
  is_dense_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.is_dense)
}

// optional bool is_transform = 10;
inline bool ProcessLidar::has_is_transform() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProcessLidar::set_has_is_transform() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProcessLidar::clear_has_is_transform() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProcessLidar::clear_is_transform() {
  is_transform_ = false;
  clear_has_is_transform();
}
inline bool ProcessLidar::is_transform() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.is_transform)
  return is_transform_;
}
inline void ProcessLidar::set_is_transform(bool value) {
  set_has_is_transform();
  is_transform_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.is_transform)
}

// optional bool is_motion_correct = 11;
inline bool ProcessLidar::has_is_motion_correct() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProcessLidar::set_has_is_motion_correct() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProcessLidar::clear_has_is_motion_correct() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProcessLidar::clear_is_motion_correct() {
  is_motion_correct_ = false;
  clear_has_is_motion_correct();
}
inline bool ProcessLidar::is_motion_correct() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.is_motion_correct)
  return is_motion_correct_;
}
inline void ProcessLidar::set_is_motion_correct(bool value) {
  set_has_is_motion_correct();
  is_motion_correct_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.ProcessLidar.is_motion_correct)
}

// repeated .robosense.localization.Proto_msg.PointXYZIT point = 12;
inline int ProcessLidar::point_size() const {
  return point_.size();
}
inline void ProcessLidar::clear_point() {
  point_.Clear();
}
inline ::robosense::localization::Proto_msg::PointXYZIT* ProcessLidar::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.ProcessLidar.point)
  return point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::robosense::localization::Proto_msg::PointXYZIT >*
ProcessLidar::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:robosense.localization.Proto_msg.ProcessLidar.point)
  return &point_;
}
inline const ::robosense::localization::Proto_msg::PointXYZIT& ProcessLidar::point(int index) const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.ProcessLidar.point)
  return point_.Get(index);
}
inline ::robosense::localization::Proto_msg::PointXYZIT* ProcessLidar::add_point() {
  // @@protoc_insertion_point(field_add:robosense.localization.Proto_msg.ProcessLidar.point)
  return point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robosense::localization::Proto_msg::PointXYZIT >&
ProcessLidar::point() const {
  // @@protoc_insertion_point(field_list:robosense.localization.Proto_msg.ProcessLidar.point)
  return point_;
}

// -------------------------------------------------------------------

// VehicleStateMsg

// optional double timestamp = 1;
inline bool VehicleStateMsg::has_timestamp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VehicleStateMsg::set_has_timestamp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VehicleStateMsg::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VehicleStateMsg::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double VehicleStateMsg::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.timestamp)
  return timestamp_;
}
inline void VehicleStateMsg::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.VehicleStateMsg.timestamp)
}

// optional uint32 seq = 2;
inline bool VehicleStateMsg::has_seq() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VehicleStateMsg::set_has_seq() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VehicleStateMsg::clear_has_seq() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VehicleStateMsg::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 VehicleStateMsg::seq() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.seq)
  return seq_;
}
inline void VehicleStateMsg::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.VehicleStateMsg.seq)
}

// optional string frame_id = 3;
inline bool VehicleStateMsg::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleStateMsg::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleStateMsg::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleStateMsg::clear_frame_id() {
  frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_frame_id();
}
inline const ::std::string& VehicleStateMsg::frame_id() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
  return frame_id_.GetNoArena();
}
inline void VehicleStateMsg::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
}
#if LANG_CXX11
inline void VehicleStateMsg::set_frame_id(::std::string&& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
}
#endif
inline void VehicleStateMsg::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
}
inline void VehicleStateMsg::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
}
inline ::std::string* VehicleStateMsg::mutable_frame_id() {
  set_has_frame_id();
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
  return frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleStateMsg::release_frame_id() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
  if (!has_frame_id()) {
    return NULL;
  }
  clear_has_frame_id();
  return frame_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleStateMsg::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
  frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.frame_id)
}

// optional string parent_frame_id = 4;
inline bool VehicleStateMsg::has_parent_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleStateMsg::set_has_parent_frame_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleStateMsg::clear_has_parent_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleStateMsg::clear_parent_frame_id() {
  parent_frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_frame_id();
}
inline const ::std::string& VehicleStateMsg::parent_frame_id() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
  return parent_frame_id_.GetNoArena();
}
inline void VehicleStateMsg::set_parent_frame_id(const ::std::string& value) {
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
}
#if LANG_CXX11
inline void VehicleStateMsg::set_parent_frame_id(::std::string&& value) {
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
}
#endif
inline void VehicleStateMsg::set_parent_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
}
inline void VehicleStateMsg::set_parent_frame_id(const char* value, size_t size) {
  set_has_parent_frame_id();
  parent_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
}
inline ::std::string* VehicleStateMsg::mutable_parent_frame_id() {
  set_has_parent_frame_id();
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
  return parent_frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleStateMsg::release_parent_frame_id() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
  if (!has_parent_frame_id()) {
    return NULL;
  }
  clear_has_parent_frame_id();
  return parent_frame_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleStateMsg::set_allocated_parent_frame_id(::std::string* parent_frame_id) {
  if (parent_frame_id != NULL) {
    set_has_parent_frame_id();
  } else {
    clear_has_parent_frame_id();
  }
  parent_frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_frame_id);
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.parent_frame_id)
}

// optional uint32 status = 5;
inline bool VehicleStateMsg::has_status() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VehicleStateMsg::set_has_status() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VehicleStateMsg::clear_has_status() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VehicleStateMsg::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 VehicleStateMsg::status() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.status)
  return status_;
}
inline void VehicleStateMsg::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.VehicleStateMsg.status)
}

// optional .robosense.localization.Proto_msg.Vector1d origin = 6;
inline bool VehicleStateMsg::has_origin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleStateMsg::set_has_origin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleStateMsg::clear_has_origin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleStateMsg::clear_origin() {
  if (origin_ != NULL) origin_->Clear();
  clear_has_origin();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_origin() const {
  return *origin_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::origin() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = origin_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.origin)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_origin() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.origin)
  clear_has_origin();
  ::robosense::localization::Proto_msg::Vector1d* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.origin)
  return origin_;
}
inline void VehicleStateMsg::set_allocated_origin(::robosense::localization::Proto_msg::Vector1d* origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete origin_;
  }
  if (origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.origin)
}

// optional .robosense.localization.Proto_msg.Vector1d fix = 7;
inline bool VehicleStateMsg::has_fix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleStateMsg::set_has_fix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleStateMsg::clear_has_fix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleStateMsg::clear_fix() {
  if (fix_ != NULL) fix_->Clear();
  clear_has_fix();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_fix() const {
  return *fix_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::fix() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = fix_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.fix)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_fix() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.fix)
  clear_has_fix();
  ::robosense::localization::Proto_msg::Vector1d* temp = fix_;
  fix_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_fix() {
  set_has_fix();
  if (fix_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    fix_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.fix)
  return fix_;
}
inline void VehicleStateMsg::set_allocated_fix(::robosense::localization::Proto_msg::Vector1d* fix) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fix_;
  }
  if (fix) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fix = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fix, submessage_arena);
    }
    set_has_fix();
  } else {
    clear_has_fix();
  }
  fix_ = fix;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.fix)
}

// optional .robosense.localization.Proto_msg.Vector1d pos = 8;
inline bool VehicleStateMsg::has_pos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleStateMsg::set_has_pos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleStateMsg::clear_has_pos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleStateMsg::clear_pos() {
  if (pos_ != NULL) pos_->Clear();
  clear_has_pos();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_pos() const {
  return *pos_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::pos() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = pos_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_pos() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.pos)
  clear_has_pos();
  ::robosense::localization::Proto_msg::Vector1d* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.pos)
  return pos_;
}
inline void VehicleStateMsg::set_allocated_pos(::robosense::localization::Proto_msg::Vector1d* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.pos)
}

// optional .robosense.localization.Proto_msg.Vector1d pos_cov = 9;
inline bool VehicleStateMsg::has_pos_cov() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleStateMsg::set_has_pos_cov() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleStateMsg::clear_has_pos_cov() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleStateMsg::clear_pos_cov() {
  if (pos_cov_ != NULL) pos_cov_->Clear();
  clear_has_pos_cov();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_pos_cov() const {
  return *pos_cov_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::pos_cov() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = pos_cov_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.pos_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_pos_cov() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.pos_cov)
  clear_has_pos_cov();
  ::robosense::localization::Proto_msg::Vector1d* temp = pos_cov_;
  pos_cov_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_pos_cov() {
  set_has_pos_cov();
  if (pos_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    pos_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.pos_cov)
  return pos_cov_;
}
inline void VehicleStateMsg::set_allocated_pos_cov(::robosense::localization::Proto_msg::Vector1d* pos_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_cov_;
  }
  if (pos_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos_cov, submessage_arena);
    }
    set_has_pos_cov();
  } else {
    clear_has_pos_cov();
  }
  pos_cov_ = pos_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.pos_cov)
}

// optional .robosense.localization.Proto_msg.Vector1d orien = 10;
inline bool VehicleStateMsg::has_orien() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleStateMsg::set_has_orien() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleStateMsg::clear_has_orien() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleStateMsg::clear_orien() {
  if (orien_ != NULL) orien_->Clear();
  clear_has_orien();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_orien() const {
  return *orien_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::orien() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = orien_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.orien)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_orien() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.orien)
  clear_has_orien();
  ::robosense::localization::Proto_msg::Vector1d* temp = orien_;
  orien_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_orien() {
  set_has_orien();
  if (orien_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    orien_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.orien)
  return orien_;
}
inline void VehicleStateMsg::set_allocated_orien(::robosense::localization::Proto_msg::Vector1d* orien) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orien_;
  }
  if (orien) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orien = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orien, submessage_arena);
    }
    set_has_orien();
  } else {
    clear_has_orien();
  }
  orien_ = orien;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.orien)
}

// optional .robosense.localization.Proto_msg.Vector1d orien_cov = 11;
inline bool VehicleStateMsg::has_orien_cov() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleStateMsg::set_has_orien_cov() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleStateMsg::clear_has_orien_cov() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleStateMsg::clear_orien_cov() {
  if (orien_cov_ != NULL) orien_cov_->Clear();
  clear_has_orien_cov();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_orien_cov() const {
  return *orien_cov_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::orien_cov() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = orien_cov_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.orien_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_orien_cov() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.orien_cov)
  clear_has_orien_cov();
  ::robosense::localization::Proto_msg::Vector1d* temp = orien_cov_;
  orien_cov_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_orien_cov() {
  set_has_orien_cov();
  if (orien_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    orien_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.orien_cov)
  return orien_cov_;
}
inline void VehicleStateMsg::set_allocated_orien_cov(::robosense::localization::Proto_msg::Vector1d* orien_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orien_cov_;
  }
  if (orien_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orien_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orien_cov, submessage_arena);
    }
    set_has_orien_cov();
  } else {
    clear_has_orien_cov();
  }
  orien_cov_ = orien_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.orien_cov)
}

// optional .robosense.localization.Proto_msg.Vector1d angular_vel = 12;
inline bool VehicleStateMsg::has_angular_vel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleStateMsg::set_has_angular_vel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleStateMsg::clear_has_angular_vel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleStateMsg::clear_angular_vel() {
  if (angular_vel_ != NULL) angular_vel_->Clear();
  clear_has_angular_vel();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_angular_vel() const {
  return *angular_vel_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::angular_vel() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = angular_vel_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_angular_vel() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel)
  clear_has_angular_vel();
  ::robosense::localization::Proto_msg::Vector1d* temp = angular_vel_;
  angular_vel_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_angular_vel() {
  set_has_angular_vel();
  if (angular_vel_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    angular_vel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel)
  return angular_vel_;
}
inline void VehicleStateMsg::set_allocated_angular_vel(::robosense::localization::Proto_msg::Vector1d* angular_vel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_vel_;
  }
  if (angular_vel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_vel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_vel, submessage_arena);
    }
    set_has_angular_vel();
  } else {
    clear_has_angular_vel();
  }
  angular_vel_ = angular_vel;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel)
}

// optional .robosense.localization.Proto_msg.Vector1d angular_vel_cov = 13;
inline bool VehicleStateMsg::has_angular_vel_cov() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleStateMsg::set_has_angular_vel_cov() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleStateMsg::clear_has_angular_vel_cov() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleStateMsg::clear_angular_vel_cov() {
  if (angular_vel_cov_ != NULL) angular_vel_cov_->Clear();
  clear_has_angular_vel_cov();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_angular_vel_cov() const {
  return *angular_vel_cov_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::angular_vel_cov() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = angular_vel_cov_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_angular_vel_cov() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel_cov)
  clear_has_angular_vel_cov();
  ::robosense::localization::Proto_msg::Vector1d* temp = angular_vel_cov_;
  angular_vel_cov_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_angular_vel_cov() {
  set_has_angular_vel_cov();
  if (angular_vel_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    angular_vel_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel_cov)
  return angular_vel_cov_;
}
inline void VehicleStateMsg::set_allocated_angular_vel_cov(::robosense::localization::Proto_msg::Vector1d* angular_vel_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_vel_cov_;
  }
  if (angular_vel_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_vel_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_vel_cov, submessage_arena);
    }
    set_has_angular_vel_cov();
  } else {
    clear_has_angular_vel_cov();
  }
  angular_vel_cov_ = angular_vel_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.angular_vel_cov)
}

// optional .robosense.localization.Proto_msg.Vector1d linear_vel = 14;
inline bool VehicleStateMsg::has_linear_vel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleStateMsg::set_has_linear_vel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleStateMsg::clear_has_linear_vel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleStateMsg::clear_linear_vel() {
  if (linear_vel_ != NULL) linear_vel_->Clear();
  clear_has_linear_vel();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_linear_vel() const {
  return *linear_vel_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::linear_vel() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = linear_vel_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_linear_vel() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel)
  clear_has_linear_vel();
  ::robosense::localization::Proto_msg::Vector1d* temp = linear_vel_;
  linear_vel_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_linear_vel() {
  set_has_linear_vel();
  if (linear_vel_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    linear_vel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel)
  return linear_vel_;
}
inline void VehicleStateMsg::set_allocated_linear_vel(::robosense::localization::Proto_msg::Vector1d* linear_vel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_vel_;
  }
  if (linear_vel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_vel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_vel, submessage_arena);
    }
    set_has_linear_vel();
  } else {
    clear_has_linear_vel();
  }
  linear_vel_ = linear_vel;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel)
}

// optional .robosense.localization.Proto_msg.Vector1d linear_vel_cov = 15;
inline bool VehicleStateMsg::has_linear_vel_cov() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VehicleStateMsg::set_has_linear_vel_cov() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VehicleStateMsg::clear_has_linear_vel_cov() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VehicleStateMsg::clear_linear_vel_cov() {
  if (linear_vel_cov_ != NULL) linear_vel_cov_->Clear();
  clear_has_linear_vel_cov();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_linear_vel_cov() const {
  return *linear_vel_cov_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::linear_vel_cov() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = linear_vel_cov_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_linear_vel_cov() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel_cov)
  clear_has_linear_vel_cov();
  ::robosense::localization::Proto_msg::Vector1d* temp = linear_vel_cov_;
  linear_vel_cov_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_linear_vel_cov() {
  set_has_linear_vel_cov();
  if (linear_vel_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    linear_vel_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel_cov)
  return linear_vel_cov_;
}
inline void VehicleStateMsg::set_allocated_linear_vel_cov(::robosense::localization::Proto_msg::Vector1d* linear_vel_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_vel_cov_;
  }
  if (linear_vel_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_vel_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_vel_cov, submessage_arena);
    }
    set_has_linear_vel_cov();
  } else {
    clear_has_linear_vel_cov();
  }
  linear_vel_cov_ = linear_vel_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.linear_vel_cov)
}

// optional .robosense.localization.Proto_msg.Vector1d acc = 16;
inline bool VehicleStateMsg::has_acc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VehicleStateMsg::set_has_acc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VehicleStateMsg::clear_has_acc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VehicleStateMsg::clear_acc() {
  if (acc_ != NULL) acc_->Clear();
  clear_has_acc();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_acc() const {
  return *acc_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::acc() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = acc_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.acc)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_acc() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.acc)
  clear_has_acc();
  ::robosense::localization::Proto_msg::Vector1d* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    acc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.acc)
  return acc_;
}
inline void VehicleStateMsg::set_allocated_acc(::robosense::localization::Proto_msg::Vector1d* acc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acc_;
  }
  if (acc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    set_has_acc();
  } else {
    clear_has_acc();
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.acc)
}

// optional .robosense.localization.Proto_msg.Vector1d acc_cov = 17;
inline bool VehicleStateMsg::has_acc_cov() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VehicleStateMsg::set_has_acc_cov() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VehicleStateMsg::clear_has_acc_cov() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VehicleStateMsg::clear_acc_cov() {
  if (acc_cov_ != NULL) acc_cov_->Clear();
  clear_has_acc_cov();
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::_internal_acc_cov() const {
  return *acc_cov_;
}
inline const ::robosense::localization::Proto_msg::Vector1d& VehicleStateMsg::acc_cov() const {
  const ::robosense::localization::Proto_msg::Vector1d* p = acc_cov_;
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.VehicleStateMsg.acc_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::localization::Proto_msg::Vector1d*>(
      &::robosense::localization::Proto_msg::_Vector1d_default_instance_);
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::release_acc_cov() {
  // @@protoc_insertion_point(field_release:robosense.localization.Proto_msg.VehicleStateMsg.acc_cov)
  clear_has_acc_cov();
  ::robosense::localization::Proto_msg::Vector1d* temp = acc_cov_;
  acc_cov_ = NULL;
  return temp;
}
inline ::robosense::localization::Proto_msg::Vector1d* VehicleStateMsg::mutable_acc_cov() {
  set_has_acc_cov();
  if (acc_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::localization::Proto_msg::Vector1d>(GetArenaNoVirtual());
    acc_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.localization.Proto_msg.VehicleStateMsg.acc_cov)
  return acc_cov_;
}
inline void VehicleStateMsg::set_allocated_acc_cov(::robosense::localization::Proto_msg::Vector1d* acc_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acc_cov_;
  }
  if (acc_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc_cov, submessage_arena);
    }
    set_has_acc_cov();
  } else {
    clear_has_acc_cov();
  }
  acc_cov_ = acc_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.localization.Proto_msg.VehicleStateMsg.acc_cov)
}

// -------------------------------------------------------------------

// MsgHeader

// optional double msgTimestamps = 1;
inline bool MsgHeader::has_msgtimestamps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHeader::set_has_msgtimestamps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHeader::clear_has_msgtimestamps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHeader::clear_msgtimestamps() {
  msgtimestamps_ = 0;
  clear_has_msgtimestamps();
}
inline double MsgHeader::msgtimestamps() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgTimestamps)
  return msgtimestamps_;
}
inline void MsgHeader::set_msgtimestamps(double value) {
  set_has_msgtimestamps();
  msgtimestamps_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgTimestamps)
}

// optional uint32 msgVersion = 2;
inline bool MsgHeader::has_msgversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHeader::set_has_msgversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHeader::clear_has_msgversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHeader::clear_msgversion() {
  msgversion_ = 0u;
  clear_has_msgversion();
}
inline ::google::protobuf::uint32 MsgHeader::msgversion() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgVersion)
  return msgversion_;
}
inline void MsgHeader::set_msgversion(::google::protobuf::uint32 value) {
  set_has_msgversion();
  msgversion_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgVersion)
}

// optional uint32 msgType = 3;
inline bool MsgHeader::has_msgtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgHeader::set_has_msgtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgHeader::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgHeader::clear_msgtype() {
  msgtype_ = 0u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 MsgHeader::msgtype() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgType)
  return msgtype_;
}
inline void MsgHeader::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgType)
}

// optional uint32 deviceId = 4;
inline bool MsgHeader::has_deviceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgHeader::set_has_deviceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgHeader::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgHeader::clear_deviceid() {
  deviceid_ = 0u;
  clear_has_deviceid();
}
inline ::google::protobuf::uint32 MsgHeader::deviceid() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.deviceId)
  return deviceid_;
}
inline void MsgHeader::set_deviceid(::google::protobuf::uint32 value) {
  set_has_deviceid();
  deviceid_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.deviceId)
}

// optional uint32 msgFrameId = 5;
inline bool MsgHeader::has_msgframeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgHeader::set_has_msgframeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgHeader::clear_has_msgframeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgHeader::clear_msgframeid() {
  msgframeid_ = 0u;
  clear_has_msgframeid();
}
inline ::google::protobuf::uint32 MsgHeader::msgframeid() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgFrameId)
  return msgframeid_;
}
inline void MsgHeader::set_msgframeid(::google::protobuf::uint32 value) {
  set_has_msgframeid();
  msgframeid_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgFrameId)
}

// optional uint32 msgTotalCnt = 6;
inline bool MsgHeader::has_msgtotalcnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgHeader::set_has_msgtotalcnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgHeader::clear_has_msgtotalcnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgHeader::clear_msgtotalcnt() {
  msgtotalcnt_ = 0u;
  clear_has_msgtotalcnt();
}
inline ::google::protobuf::uint32 MsgHeader::msgtotalcnt() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgTotalCnt)
  return msgtotalcnt_;
}
inline void MsgHeader::set_msgtotalcnt(::google::protobuf::uint32 value) {
  set_has_msgtotalcnt();
  msgtotalcnt_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgTotalCnt)
}

// optional uint32 msgLocalCnt = 7;
inline bool MsgHeader::has_msglocalcnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgHeader::set_has_msglocalcnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgHeader::clear_has_msglocalcnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgHeader::clear_msglocalcnt() {
  msglocalcnt_ = 0u;
  clear_has_msglocalcnt();
}
inline ::google::protobuf::uint32 MsgHeader::msglocalcnt() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgLocalCnt)
  return msglocalcnt_;
}
inline void MsgHeader::set_msglocalcnt(::google::protobuf::uint32 value) {
  set_has_msglocalcnt();
  msglocalcnt_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgLocalCnt)
}

// optional uint32 msgLocalLen = 8;
inline bool MsgHeader::has_msglocallen() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgHeader::set_has_msglocallen() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgHeader::clear_has_msglocallen() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgHeader::clear_msglocallen() {
  msglocallen_ = 0u;
  clear_has_msglocallen();
}
inline ::google::protobuf::uint32 MsgHeader::msglocallen() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgLocalLen)
  return msglocallen_;
}
inline void MsgHeader::set_msglocallen(::google::protobuf::uint32 value) {
  set_has_msglocallen();
  msglocallen_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgLocalLen)
}

// optional uint32 msgIndex = 9;
inline bool MsgHeader::has_msgindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgHeader::set_has_msgindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgHeader::clear_has_msgindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgHeader::clear_msgindex() {
  msgindex_ = 0u;
  clear_has_msgindex();
}
inline ::google::protobuf::uint32 MsgHeader::msgindex() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgIndex)
  return msgindex_;
}
inline void MsgHeader::set_msgindex(::google::protobuf::uint32 value) {
  set_has_msgindex();
  msgindex_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgIndex)
}

// optional uint32 msgTotalFragment = 10;
inline bool MsgHeader::has_msgtotalfragment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgHeader::set_has_msgtotalfragment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgHeader::clear_has_msgtotalfragment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgHeader::clear_msgtotalfragment() {
  msgtotalfragment_ = 0u;
  clear_has_msgtotalfragment();
}
inline ::google::protobuf::uint32 MsgHeader::msgtotalfragment() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgTotalFragment)
  return msgtotalfragment_;
}
inline void MsgHeader::set_msgtotalfragment(::google::protobuf::uint32 value) {
  set_has_msgtotalfragment();
  msgtotalfragment_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgTotalFragment)
}

// optional uint32 msgFragmentIndex = 11;
inline bool MsgHeader::has_msgfragmentindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgHeader::set_has_msgfragmentindex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgHeader::clear_has_msgfragmentindex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgHeader::clear_msgfragmentindex() {
  msgfragmentindex_ = 0u;
  clear_has_msgfragmentindex();
}
inline ::google::protobuf::uint32 MsgHeader::msgfragmentindex() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgFragmentIndex)
  return msgfragmentindex_;
}
inline void MsgHeader::set_msgfragmentindex(::google::protobuf::uint32 value) {
  set_has_msgfragmentindex();
  msgfragmentindex_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgFragmentIndex)
}

// optional uint32 msgRes0 = 12;
inline bool MsgHeader::has_msgres0() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgHeader::set_has_msgres0() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgHeader::clear_has_msgres0() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgHeader::clear_msgres0() {
  msgres0_ = 0u;
  clear_has_msgres0();
}
inline ::google::protobuf::uint32 MsgHeader::msgres0() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgRes0)
  return msgres0_;
}
inline void MsgHeader::set_msgres0(::google::protobuf::uint32 value) {
  set_has_msgres0();
  msgres0_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgRes0)
}

// optional uint32 msgCheck16 = 13;
inline bool MsgHeader::has_msgcheck16() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MsgHeader::set_has_msgcheck16() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MsgHeader::clear_has_msgcheck16() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MsgHeader::clear_msgcheck16() {
  msgcheck16_ = 0u;
  clear_has_msgcheck16();
}
inline ::google::protobuf::uint32 MsgHeader::msgcheck16() const {
  // @@protoc_insertion_point(field_get:robosense.localization.Proto_msg.MsgHeader.msgCheck16)
  return msgcheck16_;
}
inline void MsgHeader::set_msgcheck16(::google::protobuf::uint32 value) {
  set_has_msgcheck16();
  msgcheck16_ = value;
  // @@protoc_insertion_point(field_set:robosense.localization.Proto_msg.MsgHeader.msgCheck16)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto_msg
}  // namespace localization
}  // namespace robosense

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Proto_5fmsg_2eLoc_2eproto
