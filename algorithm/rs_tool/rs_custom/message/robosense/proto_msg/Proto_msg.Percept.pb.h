// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Proto_msg.Percept.proto

#ifndef PROTOBUF_INCLUDED_Proto_5fmsg_2ePercept_2eproto
#define PROTOBUF_INCLUDED_Proto_5fmsg_2ePercept_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Proto_5fmsg_2ePercept_2eproto 

namespace protobuf_Proto_5fmsg_2ePercept_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[23];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Proto_5fmsg_2ePercept_2eproto
namespace robosense {
namespace perception {
namespace Proto_msg {
class CoreInfos;
class CoreInfosDefaultTypeInternal;
extern CoreInfosDefaultTypeInternal _CoreInfos_default_instance_;
class Curve;
class CurveDefaultTypeInternal;
extern CurveDefaultTypeInternal _Curve_default_instance_;
class EndPoints;
class EndPointsDefaultTypeInternal;
extern EndPointsDefaultTypeInternal _EndPoints_default_instance_;
class FreeSpaces;
class FreeSpacesDefaultTypeInternal;
extern FreeSpacesDefaultTypeInternal _FreeSpaces_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class Lanes;
class LanesDefaultTypeInternal;
extern LanesDefaultTypeInternal _Lanes_default_instance_;
class MsgHeader;
class MsgHeaderDefaultTypeInternal;
extern MsgHeaderDefaultTypeInternal _MsgHeader_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Point2f;
class Point2fDefaultTypeInternal;
extern Point2fDefaultTypeInternal _Point2f_default_instance_;
class Point3d;
class Point3dDefaultTypeInternal;
extern Point3dDefaultTypeInternal _Point3d_default_instance_;
class Point3f;
class Point3fDefaultTypeInternal;
extern Point3fDefaultTypeInternal _Point3f_default_instance_;
class PointCloud;
class PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class PointXYZITL;
class PointXYZITLDefaultTypeInternal;
extern PointXYZITLDefaultTypeInternal _PointXYZITL_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseInfo;
class PoseInfoDefaultTypeInternal;
extern PoseInfoDefaultTypeInternal _PoseInfo_default_instance_;
class RoadEdge;
class RoadEdgeDefaultTypeInternal;
extern RoadEdgeDefaultTypeInternal _RoadEdge_default_instance_;
class RoadEdges;
class RoadEdgesDefaultTypeInternal;
extern RoadEdgesDefaultTypeInternal _RoadEdges_default_instance_;
class SupplementInfos;
class SupplementInfosDefaultTypeInternal;
extern SupplementInfosDefaultTypeInternal _SupplementInfos_default_instance_;
class Vector1f;
class Vector1fDefaultTypeInternal;
extern Vector1fDefaultTypeInternal _Vector1f_default_instance_;
class Vector1i;
class Vector1iDefaultTypeInternal;
extern Vector1iDefaultTypeInternal _Vector1i_default_instance_;
class Vector3f;
class Vector3fDefaultTypeInternal;
extern Vector3fDefaultTypeInternal _Vector3f_default_instance_;
class VectorFreeSpaceType;
class VectorFreeSpaceTypeDefaultTypeInternal;
extern VectorFreeSpaceTypeDefaultTypeInternal _VectorFreeSpaceType_default_instance_;
class VectorObjType;
class VectorObjTypeDefaultTypeInternal;
extern VectorObjTypeDefaultTypeInternal _VectorObjType_default_instance_;
}  // namespace Proto_msg
}  // namespace perception
}  // namespace robosense
namespace google {
namespace protobuf {
template<> ::robosense::perception::Proto_msg::CoreInfos* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::CoreInfos>(Arena*);
template<> ::robosense::perception::Proto_msg::Curve* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Curve>(Arena*);
template<> ::robosense::perception::Proto_msg::EndPoints* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::EndPoints>(Arena*);
template<> ::robosense::perception::Proto_msg::FreeSpaces* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::FreeSpaces>(Arena*);
template<> ::robosense::perception::Proto_msg::Lane* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Lane>(Arena*);
template<> ::robosense::perception::Proto_msg::Lanes* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Lanes>(Arena*);
template<> ::robosense::perception::Proto_msg::MsgHeader* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::MsgHeader>(Arena*);
template<> ::robosense::perception::Proto_msg::Object* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Object>(Arena*);
template<> ::robosense::perception::Proto_msg::Point2f* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Point2f>(Arena*);
template<> ::robosense::perception::Proto_msg::Point3d* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Point3d>(Arena*);
template<> ::robosense::perception::Proto_msg::Point3f* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(Arena*);
template<> ::robosense::perception::Proto_msg::PointCloud* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::PointCloud>(Arena*);
template<> ::robosense::perception::Proto_msg::PointXYZITL* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::PointXYZITL>(Arena*);
template<> ::robosense::perception::Proto_msg::Pose* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Pose>(Arena*);
template<> ::robosense::perception::Proto_msg::PoseInfo* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::PoseInfo>(Arena*);
template<> ::robosense::perception::Proto_msg::RoadEdge* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::RoadEdge>(Arena*);
template<> ::robosense::perception::Proto_msg::RoadEdges* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::RoadEdges>(Arena*);
template<> ::robosense::perception::Proto_msg::SupplementInfos* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::SupplementInfos>(Arena*);
template<> ::robosense::perception::Proto_msg::Vector1f* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Vector1f>(Arena*);
template<> ::robosense::perception::Proto_msg::Vector1i* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Vector1i>(Arena*);
template<> ::robosense::perception::Proto_msg::Vector3f* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::Vector3f>(Arena*);
template<> ::robosense::perception::Proto_msg::VectorFreeSpaceType* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::VectorFreeSpaceType>(Arena*);
template<> ::robosense::perception::Proto_msg::VectorObjType* Arena::CreateMaybeMessage<::robosense::perception::Proto_msg::VectorObjType>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace robosense {
namespace perception {
namespace Proto_msg {

enum ObjectType {
  OBJECT_UNKNOWN = 0,
  OBJECT_PED = 1,
  OBJECT_BIC = 2,
  OBJECT_CAR = 3,
  OBJECT_TRUCK_BUS = 4,
  OBJECT_ULTRA_VEHICLE = 5,
  OBJECT_CONE = 6,
  OBJECT_MAX_OBJ_TYPE_NUM = 7
};
bool ObjectType_IsValid(int value);
const ObjectType ObjectType_MIN = OBJECT_UNKNOWN;
const ObjectType ObjectType_MAX = OBJECT_MAX_OBJ_TYPE_NUM;
const int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectType_descriptor();
inline const ::std::string& ObjectType_Name(ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectType_descriptor(), value);
}
inline bool ObjectType_Parse(
    const ::std::string& name, ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectType>(
    ObjectType_descriptor(), name, value);
}
enum MotionType {
  MOTION_UNKNOWN = 0,
  MOTION_MOVING = 1,
  MOTION_MOVABLE = 2,
  MOTION_STATIONARY = 3,
  MOTION_MAX_MOTION_STATE_NUM = 4
};
bool MotionType_IsValid(int value);
const MotionType MotionType_MIN = MOTION_UNKNOWN;
const MotionType MotionType_MAX = MOTION_MAX_MOTION_STATE_NUM;
const int MotionType_ARRAYSIZE = MotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionType_descriptor();
inline const ::std::string& MotionType_Name(MotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionType_descriptor(), value);
}
inline bool MotionType_Parse(
    const ::std::string& name, MotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionType>(
    MotionType_descriptor(), name, value);
}
enum SizeType {
  SIZE_SMALL = 0,
  SIZE_MEDIUM = 1,
  SIZE_LARGE = 2,
  SIZE_MAX_SIZE_TYPE_NUM = 3
};
bool SizeType_IsValid(int value);
const SizeType SizeType_MIN = SIZE_SMALL;
const SizeType SizeType_MAX = SIZE_MAX_SIZE_TYPE_NUM;
const int SizeType_ARRAYSIZE = SizeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SizeType_descriptor();
inline const ::std::string& SizeType_Name(SizeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SizeType_descriptor(), value);
}
inline bool SizeType_Parse(
    const ::std::string& name, SizeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SizeType>(
    SizeType_descriptor(), name, value);
}
enum ModeType {
  MODE_BSD = 1,
  MODE_FOCUS = 2,
  MODE_PREDICT = 3
};
bool ModeType_IsValid(int value);
const ModeType ModeType_MIN = MODE_BSD;
const ModeType ModeType_MAX = MODE_PREDICT;
const int ModeType_ARRAYSIZE = ModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModeType_descriptor();
inline const ::std::string& ModeType_Name(ModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModeType_descriptor(), value);
}
inline bool ModeType_Parse(
    const ::std::string& name, ModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModeType>(
    ModeType_descriptor(), name, value);
}
enum TrackingState {
  TRACK_UNKNOWN = 0,
  TRACK_INIT = 1,
  TRACK_STABLE = 2,
  TRACK_PREDICTION = 3
};
bool TrackingState_IsValid(int value);
const TrackingState TrackingState_MIN = TRACK_UNKNOWN;
const TrackingState TrackingState_MAX = TRACK_PREDICTION;
const int TrackingState_ARRAYSIZE = TrackingState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrackingState_descriptor();
inline const ::std::string& TrackingState_Name(TrackingState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrackingState_descriptor(), value);
}
inline bool TrackingState_Parse(
    const ::std::string& name, TrackingState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackingState>(
    TrackingState_descriptor(), name, value);
}
enum AttentionType {
  ATTENTION_NONE = 0,
  ATTENTION_ATTENTION = 1
};
bool AttentionType_IsValid(int value);
const AttentionType AttentionType_MIN = ATTENTION_NONE;
const AttentionType AttentionType_MAX = ATTENTION_ATTENTION;
const int AttentionType_ARRAYSIZE = AttentionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AttentionType_descriptor();
inline const ::std::string& AttentionType_Name(AttentionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AttentionType_descriptor(), value);
}
inline bool AttentionType_Parse(
    const ::std::string& name, AttentionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AttentionType>(
    AttentionType_descriptor(), name, value);
}
enum GpsType {
  GPS_CENTER = 0,
  GPS_CENTROID = 1,
  GPS_NEAREST = 2
};
bool GpsType_IsValid(int value);
const GpsType GpsType_MIN = GPS_CENTER;
const GpsType GpsType_MAX = GPS_NEAREST;
const int GpsType_ARRAYSIZE = GpsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpsType_descriptor();
inline const ::std::string& GpsType_Name(GpsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpsType_descriptor(), value);
}
inline bool GpsType_Parse(
    const ::std::string& name, GpsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpsType>(
    GpsType_descriptor(), name, value);
}
enum FreeSpaceType {
  FREE_STATIONARY = 0,
  FREE_DYNAMIC = 1,
  FREE_UNKNOWN = 2
};
bool FreeSpaceType_IsValid(int value);
const FreeSpaceType FreeSpaceType_MIN = FREE_STATIONARY;
const FreeSpaceType FreeSpaceType_MAX = FREE_UNKNOWN;
const int FreeSpaceType_ARRAYSIZE = FreeSpaceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FreeSpaceType_descriptor();
inline const ::std::string& FreeSpaceType_Name(FreeSpaceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FreeSpaceType_descriptor(), value);
}
inline bool FreeSpaceType_Parse(
    const ::std::string& name, FreeSpaceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FreeSpaceType>(
    FreeSpaceType_descriptor(), name, value);
}
enum RoadedgePosition {
  ROAD_LEFT = 1,
  ROAD_UNKNOWN = 0,
  ROAD_RIGHT = -1
};
bool RoadedgePosition_IsValid(int value);
const RoadedgePosition RoadedgePosition_MIN = ROAD_RIGHT;
const RoadedgePosition RoadedgePosition_MAX = ROAD_LEFT;
const int RoadedgePosition_ARRAYSIZE = RoadedgePosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadedgePosition_descriptor();
inline const ::std::string& RoadedgePosition_Name(RoadedgePosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadedgePosition_descriptor(), value);
}
inline bool RoadedgePosition_Parse(
    const ::std::string& name, RoadedgePosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadedgePosition>(
    RoadedgePosition_descriptor(), name, value);
}
enum LanePosition {
  LANE_UNKNOWN = 7,
  LANE_LEFT_SIXTH = 6,
  LANE_LEFT_FIFTH = 5,
  LANE_LEFT_FOURTH = 4,
  LANE_LEFT_THIRD = 3,
  LANE_LEFT_ADJACENT = 2,
  LANE_LEFT_EGO = 1,
  LANE_EGO_LANE = 0,
  LANE_RIGHT_EGO = -1,
  LANE_RIGHT_ADJACENT = -2,
  LANE_RIGHT_THIRD = -3,
  LANE_RIGHT_FOURTH = -4,
  LANE_RIGHT_FIFTH = -5,
  LANE_RIGHT_SIXTH = -6,
  LANE_OFF_DRIVABLE = -7
};
bool LanePosition_IsValid(int value);
const LanePosition LanePosition_MIN = LANE_OFF_DRIVABLE;
const LanePosition LanePosition_MAX = LANE_UNKNOWN;
const int LanePosition_ARRAYSIZE = LanePosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* LanePosition_descriptor();
inline const ::std::string& LanePosition_Name(LanePosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    LanePosition_descriptor(), value);
}
inline bool LanePosition_Parse(
    const ::std::string& name, LanePosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LanePosition>(
    LanePosition_descriptor(), name, value);
}
enum MeasureStatus {
  ROAD_DETECTION = 0,
  ROAD_PREDICTION = 1
};
bool MeasureStatus_IsValid(int value);
const MeasureStatus MeasureStatus_MIN = ROAD_DETECTION;
const MeasureStatus MeasureStatus_MAX = ROAD_PREDICTION;
const int MeasureStatus_ARRAYSIZE = MeasureStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeasureStatus_descriptor();
inline const ::std::string& MeasureStatus_Name(MeasureStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeasureStatus_descriptor(), value);
}
inline bool MeasureStatus_Parse(
    const ::std::string& name, MeasureStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeasureStatus>(
    MeasureStatus_descriptor(), name, value);
}
// ===================================================================

class Point2f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Point2f) */ {
 public:
  Point2f();
  virtual ~Point2f();

  Point2f(const Point2f& from);

  inline Point2f& operator=(const Point2f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point2f(Point2f&& from) noexcept
    : Point2f() {
    *this = ::std::move(from);
  }

  inline Point2f& operator=(Point2f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point2f* internal_default_instance() {
    return reinterpret_cast<const Point2f*>(
               &_Point2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point2f* other);
  friend void swap(Point2f& a, Point2f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point2f* New() const final {
    return CreateMaybeMessage<Point2f>(NULL);
  }

  Point2f* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point2f>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point2f& from);
  void MergeFrom(const Point2f& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Point2f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point3f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Point3f) */ {
 public:
  Point3f();
  virtual ~Point3f();

  Point3f(const Point3f& from);

  inline Point3f& operator=(const Point3f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point3f(Point3f&& from) noexcept
    : Point3f() {
    *this = ::std::move(from);
  }

  inline Point3f& operator=(Point3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point3f* internal_default_instance() {
    return reinterpret_cast<const Point3f*>(
               &_Point3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Point3f* other);
  friend void swap(Point3f& a, Point3f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point3f* New() const final {
    return CreateMaybeMessage<Point3f>(NULL);
  }

  Point3f* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point3f>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point3f& from);
  void MergeFrom(const Point3f& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Point3f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point3d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Point3d) */ {
 public:
  Point3d();
  virtual ~Point3d();

  Point3d(const Point3d& from);

  inline Point3d& operator=(const Point3d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point3d(Point3d&& from) noexcept
    : Point3d() {
    *this = ::std::move(from);
  }

  inline Point3d& operator=(Point3d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point3d* internal_default_instance() {
    return reinterpret_cast<const Point3d*>(
               &_Point3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Point3d* other);
  friend void swap(Point3d& a, Point3d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point3d* New() const final {
    return CreateMaybeMessage<Point3d>(NULL);
  }

  Point3d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point3d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point3d& from);
  void MergeFrom(const Point3d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Point3d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointXYZITL : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.PointXYZITL) */ {
 public:
  PointXYZITL();
  virtual ~PointXYZITL();

  PointXYZITL(const PointXYZITL& from);

  inline PointXYZITL& operator=(const PointXYZITL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointXYZITL(PointXYZITL&& from) noexcept
    : PointXYZITL() {
    *this = ::std::move(from);
  }

  inline PointXYZITL& operator=(PointXYZITL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointXYZITL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointXYZITL* internal_default_instance() {
    return reinterpret_cast<const PointXYZITL*>(
               &_PointXYZITL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PointXYZITL* other);
  friend void swap(PointXYZITL& a, PointXYZITL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointXYZITL* New() const final {
    return CreateMaybeMessage<PointXYZITL>(NULL);
  }

  PointXYZITL* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointXYZITL>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointXYZITL& from);
  void MergeFrom(const PointXYZITL& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointXYZITL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional uint32 intensity = 4;
  bool has_intensity() const;
  void clear_intensity();
  static const int kIntensityFieldNumber = 4;
  ::google::protobuf::uint32 intensity() const;
  void set_intensity(::google::protobuf::uint32 value);

  // optional double timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  double timestamp() const;
  void set_timestamp(double value);

  // optional int32 label = 6;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 6;
  ::google::protobuf::int32 label() const;
  void set_label(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.PointXYZITL)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_intensity();
  void clear_has_intensity();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_label();
  void clear_has_label();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  ::google::protobuf::uint32 intensity_;
  double timestamp_;
  ::google::protobuf::int32 label_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vector1i : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Vector1i) */ {
 public:
  Vector1i();
  virtual ~Vector1i();

  Vector1i(const Vector1i& from);

  inline Vector1i& operator=(const Vector1i& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector1i(Vector1i&& from) noexcept
    : Vector1i() {
    *this = ::std::move(from);
  }

  inline Vector1i& operator=(Vector1i&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector1i& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector1i* internal_default_instance() {
    return reinterpret_cast<const Vector1i*>(
               &_Vector1i_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Vector1i* other);
  friend void swap(Vector1i& a, Vector1i& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector1i* New() const final {
    return CreateMaybeMessage<Vector1i>(NULL);
  }

  Vector1i* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector1i>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector1i& from);
  void MergeFrom(const Vector1i& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector1i* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::google::protobuf::int32 data(int index) const;
  void set_data(int index, ::google::protobuf::int32 value);
  void add_data(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Vector1i)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vector1f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Vector1f) */ {
 public:
  Vector1f();
  virtual ~Vector1f();

  Vector1f(const Vector1f& from);

  inline Vector1f& operator=(const Vector1f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector1f(Vector1f&& from) noexcept
    : Vector1f() {
    *this = ::std::move(from);
  }

  inline Vector1f& operator=(Vector1f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector1f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector1f* internal_default_instance() {
    return reinterpret_cast<const Vector1f*>(
               &_Vector1f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Vector1f* other);
  friend void swap(Vector1f& a, Vector1f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector1f* New() const final {
    return CreateMaybeMessage<Vector1f>(NULL);
  }

  Vector1f* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector1f>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector1f& from);
  void MergeFrom(const Vector1f& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector1f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Vector1f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vector3f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Vector3f) */ {
 public:
  Vector3f();
  virtual ~Vector3f();

  Vector3f(const Vector3f& from);

  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3f(Vector3f&& from) noexcept
    : Vector3f() {
    *this = ::std::move(from);
  }

  inline Vector3f& operator=(Vector3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3f* internal_default_instance() {
    return reinterpret_cast<const Vector3f*>(
               &_Vector3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Vector3f* other);
  friend void swap(Vector3f& a, Vector3f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3f* New() const final {
    return CreateMaybeMessage<Vector3f>(NULL);
  }

  Vector3f* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector3f>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector3f& from);
  void MergeFrom(const Vector3f& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robosense.perception.Proto_msg.Point3f data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::robosense::perception::Proto_msg::Point3f* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Point3f >*
      mutable_data();
  const ::robosense::perception::Proto_msg::Point3f& data(int index) const;
  ::robosense::perception::Proto_msg::Point3f* add_data();
  const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Point3f >&
      data() const;

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Vector3f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Point3f > data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VectorObjType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.VectorObjType) */ {
 public:
  VectorObjType();
  virtual ~VectorObjType();

  VectorObjType(const VectorObjType& from);

  inline VectorObjType& operator=(const VectorObjType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VectorObjType(VectorObjType&& from) noexcept
    : VectorObjType() {
    *this = ::std::move(from);
  }

  inline VectorObjType& operator=(VectorObjType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorObjType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorObjType* internal_default_instance() {
    return reinterpret_cast<const VectorObjType*>(
               &_VectorObjType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(VectorObjType* other);
  friend void swap(VectorObjType& a, VectorObjType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VectorObjType* New() const final {
    return CreateMaybeMessage<VectorObjType>(NULL);
  }

  VectorObjType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VectorObjType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VectorObjType& from);
  void MergeFrom(const VectorObjType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorObjType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robosense.perception.Proto_msg.ObjectType data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::robosense::perception::Proto_msg::ObjectType data(int index) const;
  void set_data(int index, ::robosense::perception::Proto_msg::ObjectType value);
  void add_data(::robosense::perception::Proto_msg::ObjectType value);
  const ::google::protobuf::RepeatedField<int>& data() const;
  ::google::protobuf::RepeatedField<int>* mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.VectorObjType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(NULL);
  }

  Pose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional float roll = 4;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 4;
  float roll() const;
  void set_roll(float value);

  // optional float pitch = 5;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 5;
  float pitch() const;
  void set_pitch(float value);

  // optional float yaw = 6;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 6;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Pose)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_roll();
  void clear_has_roll();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_yaw();
  void clear_has_yaw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  float roll_;
  float pitch_;
  float yaw_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PoseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.PoseInfo) */ {
 public:
  PoseInfo();
  virtual ~PoseInfo();

  PoseInfo(const PoseInfo& from);

  inline PoseInfo& operator=(const PoseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseInfo(PoseInfo&& from) noexcept
    : PoseInfo() {
    *this = ::std::move(from);
  }

  inline PoseInfo& operator=(PoseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseInfo* internal_default_instance() {
    return reinterpret_cast<const PoseInfo*>(
               &_PoseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PoseInfo* other);
  friend void swap(PoseInfo& a, PoseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseInfo* New() const final {
    return CreateMaybeMessage<PoseInfo>(NULL);
  }

  PoseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PoseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PoseInfo& from);
  void MergeFrom(const PoseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.Pose pose = 2;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  private:
  const ::robosense::perception::Proto_msg::Pose& _internal_pose() const;
  public:
  const ::robosense::perception::Proto_msg::Pose& pose() const;
  ::robosense::perception::Proto_msg::Pose* release_pose();
  ::robosense::perception::Proto_msg::Pose* mutable_pose();
  void set_allocated_pose(::robosense::perception::Proto_msg::Pose* pose);

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.PoseInfo)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_pose();
  void clear_has_pose();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::Pose* pose_;
  double timestamp_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VectorFreeSpaceType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.VectorFreeSpaceType) */ {
 public:
  VectorFreeSpaceType();
  virtual ~VectorFreeSpaceType();

  VectorFreeSpaceType(const VectorFreeSpaceType& from);

  inline VectorFreeSpaceType& operator=(const VectorFreeSpaceType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VectorFreeSpaceType(VectorFreeSpaceType&& from) noexcept
    : VectorFreeSpaceType() {
    *this = ::std::move(from);
  }

  inline VectorFreeSpaceType& operator=(VectorFreeSpaceType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorFreeSpaceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorFreeSpaceType* internal_default_instance() {
    return reinterpret_cast<const VectorFreeSpaceType*>(
               &_VectorFreeSpaceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(VectorFreeSpaceType* other);
  friend void swap(VectorFreeSpaceType& a, VectorFreeSpaceType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VectorFreeSpaceType* New() const final {
    return CreateMaybeMessage<VectorFreeSpaceType>(NULL);
  }

  VectorFreeSpaceType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VectorFreeSpaceType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VectorFreeSpaceType& from);
  void MergeFrom(const VectorFreeSpaceType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorFreeSpaceType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robosense.perception.Proto_msg.FreeSpaceType data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::robosense::perception::Proto_msg::FreeSpaceType data(int index) const;
  void set_data(int index, ::robosense::perception::Proto_msg::FreeSpaceType value);
  void add_data(::robosense::perception::Proto_msg::FreeSpaceType value);
  const ::google::protobuf::RepeatedField<int>& data() const;
  ::google::protobuf::RepeatedField<int>* mutable_data();

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.VectorFreeSpaceType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> data_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FreeSpaces : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.FreeSpaces) */ {
 public:
  FreeSpaces();
  virtual ~FreeSpaces();

  FreeSpaces(const FreeSpaces& from);

  inline FreeSpaces& operator=(const FreeSpaces& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreeSpaces(FreeSpaces&& from) noexcept
    : FreeSpaces() {
    *this = ::std::move(from);
  }

  inline FreeSpaces& operator=(FreeSpaces&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeSpaces& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreeSpaces* internal_default_instance() {
    return reinterpret_cast<const FreeSpaces*>(
               &_FreeSpaces_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FreeSpaces* other);
  friend void swap(FreeSpaces& a, FreeSpaces& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreeSpaces* New() const final {
    return CreateMaybeMessage<FreeSpaces>(NULL);
  }

  FreeSpaces* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FreeSpaces>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FreeSpaces& from);
  void MergeFrom(const FreeSpaces& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreeSpaces* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.Vector3f fs_pts = 2;
  bool has_fs_pts() const;
  void clear_fs_pts();
  static const int kFsPtsFieldNumber = 2;
  private:
  const ::robosense::perception::Proto_msg::Vector3f& _internal_fs_pts() const;
  public:
  const ::robosense::perception::Proto_msg::Vector3f& fs_pts() const;
  ::robosense::perception::Proto_msg::Vector3f* release_fs_pts();
  ::robosense::perception::Proto_msg::Vector3f* mutable_fs_pts();
  void set_allocated_fs_pts(::robosense::perception::Proto_msg::Vector3f* fs_pts);

  // optional .robosense.perception.Proto_msg.Vector1f fs_confidence = 3;
  bool has_fs_confidence() const;
  void clear_fs_confidence();
  static const int kFsConfidenceFieldNumber = 3;
  private:
  const ::robosense::perception::Proto_msg::Vector1f& _internal_fs_confidence() const;
  public:
  const ::robosense::perception::Proto_msg::Vector1f& fs_confidence() const;
  ::robosense::perception::Proto_msg::Vector1f* release_fs_confidence();
  ::robosense::perception::Proto_msg::Vector1f* mutable_fs_confidence();
  void set_allocated_fs_confidence(::robosense::perception::Proto_msg::Vector1f* fs_confidence);

  // optional .robosense.perception.Proto_msg.VectorFreeSpaceType fs_types = 4;
  bool has_fs_types() const;
  void clear_fs_types();
  static const int kFsTypesFieldNumber = 4;
  private:
  const ::robosense::perception::Proto_msg::VectorFreeSpaceType& _internal_fs_types() const;
  public:
  const ::robosense::perception::Proto_msg::VectorFreeSpaceType& fs_types() const;
  ::robosense::perception::Proto_msg::VectorFreeSpaceType* release_fs_types();
  ::robosense::perception::Proto_msg::VectorFreeSpaceType* mutable_fs_types();
  void set_allocated_fs_types(::robosense::perception::Proto_msg::VectorFreeSpaceType* fs_types);

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.FreeSpaces)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_fs_pts();
  void clear_has_fs_pts();
  void set_has_fs_confidence();
  void clear_has_fs_confidence();
  void set_has_fs_types();
  void clear_has_fs_types();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::Vector3f* fs_pts_;
  ::robosense::perception::Proto_msg::Vector1f* fs_confidence_;
  ::robosense::perception::Proto_msg::VectorFreeSpaceType* fs_types_;
  double timestamp_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SupplementInfos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.SupplementInfos) */ {
 public:
  SupplementInfos();
  virtual ~SupplementInfos();

  SupplementInfos(const SupplementInfos& from);

  inline SupplementInfos& operator=(const SupplementInfos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SupplementInfos(SupplementInfos&& from) noexcept
    : SupplementInfos() {
    *this = ::std::move(from);
  }

  inline SupplementInfos& operator=(SupplementInfos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SupplementInfos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SupplementInfos* internal_default_instance() {
    return reinterpret_cast<const SupplementInfos*>(
               &_SupplementInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SupplementInfos* other);
  friend void swap(SupplementInfos& a, SupplementInfos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SupplementInfos* New() const final {
    return CreateMaybeMessage<SupplementInfos>(NULL);
  }

  SupplementInfos* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SupplementInfos>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SupplementInfos& from);
  void MergeFrom(const SupplementInfos& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplementInfos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.Vector3f polygon = 2;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  private:
  const ::robosense::perception::Proto_msg::Vector3f& _internal_polygon() const;
  public:
  const ::robosense::perception::Proto_msg::Vector3f& polygon() const;
  ::robosense::perception::Proto_msg::Vector3f* release_polygon();
  ::robosense::perception::Proto_msg::Vector3f* mutable_polygon();
  void set_allocated_polygon(::robosense::perception::Proto_msg::Vector3f* polygon);

  // optional .robosense.perception.Proto_msg.Vector1f latent_types = 5;
  bool has_latent_types() const;
  void clear_latent_types();
  static const int kLatentTypesFieldNumber = 5;
  private:
  const ::robosense::perception::Proto_msg::Vector1f& _internal_latent_types() const;
  public:
  const ::robosense::perception::Proto_msg::Vector1f& latent_types() const;
  ::robosense::perception::Proto_msg::Vector1f* release_latent_types();
  ::robosense::perception::Proto_msg::Vector1f* mutable_latent_types();
  void set_allocated_latent_types(::robosense::perception::Proto_msg::Vector1f* latent_types);

  // optional .robosense.perception.Proto_msg.Point3f geo_center = 10;
  bool has_geo_center() const;
  void clear_geo_center();
  static const int kGeoCenterFieldNumber = 10;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_geo_center() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& geo_center() const;
  ::robosense::perception::Proto_msg::Point3f* release_geo_center();
  ::robosense::perception::Proto_msg::Point3f* mutable_geo_center();
  void set_allocated_geo_center(::robosense::perception::Proto_msg::Point3f* geo_center);

  // optional .robosense.perception.Proto_msg.Point3f geo_size = 11;
  bool has_geo_size() const;
  void clear_geo_size();
  static const int kGeoSizeFieldNumber = 11;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_geo_size() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& geo_size() const;
  ::robosense::perception::Proto_msg::Point3f* release_geo_size();
  ::robosense::perception::Proto_msg::Point3f* mutable_geo_size();
  void set_allocated_geo_size(::robosense::perception::Proto_msg::Point3f* geo_size);

  // optional .robosense.perception.Proto_msg.Vector3f trajectory = 12;
  bool has_trajectory() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 12;
  private:
  const ::robosense::perception::Proto_msg::Vector3f& _internal_trajectory() const;
  public:
  const ::robosense::perception::Proto_msg::Vector3f& trajectory() const;
  ::robosense::perception::Proto_msg::Vector3f* release_trajectory();
  ::robosense::perception::Proto_msg::Vector3f* mutable_trajectory();
  void set_allocated_trajectory(::robosense::perception::Proto_msg::Vector3f* trajectory);

  // optional .robosense.perception.Proto_msg.Vector3f history_velocity = 13;
  bool has_history_velocity() const;
  void clear_history_velocity();
  static const int kHistoryVelocityFieldNumber = 13;
  private:
  const ::robosense::perception::Proto_msg::Vector3f& _internal_history_velocity() const;
  public:
  const ::robosense::perception::Proto_msg::Vector3f& history_velocity() const;
  ::robosense::perception::Proto_msg::Vector3f* release_history_velocity();
  ::robosense::perception::Proto_msg::Vector3f* mutable_history_velocity();
  void set_allocated_history_velocity(::robosense::perception::Proto_msg::Vector3f* history_velocity);

  // optional .robosense.perception.Proto_msg.VectorObjType history_type = 14;
  bool has_history_type() const;
  void clear_history_type();
  static const int kHistoryTypeFieldNumber = 14;
  private:
  const ::robosense::perception::Proto_msg::VectorObjType& _internal_history_type() const;
  public:
  const ::robosense::perception::Proto_msg::VectorObjType& history_type() const;
  ::robosense::perception::Proto_msg::VectorObjType* release_history_type();
  ::robosense::perception::Proto_msg::VectorObjType* mutable_history_type();
  void set_allocated_history_type(::robosense::perception::Proto_msg::VectorObjType* history_type);

  // optional .robosense.perception.Proto_msg.Point3d gps_info = 16;
  bool has_gps_info() const;
  void clear_gps_info();
  static const int kGpsInfoFieldNumber = 16;
  private:
  const ::robosense::perception::Proto_msg::Point3d& _internal_gps_info() const;
  public:
  const ::robosense::perception::Proto_msg::Point3d& gps_info() const;
  ::robosense::perception::Proto_msg::Point3d* release_gps_info();
  ::robosense::perception::Proto_msg::Point3d* mutable_gps_info();
  void set_allocated_gps_info(::robosense::perception::Proto_msg::Point3d* gps_info);

  // optional int32 unique_id = 1;
  bool has_unique_id() const;
  void clear_unique_id();
  static const int kUniqueIdFieldNumber = 1;
  ::google::protobuf::int32 unique_id() const;
  void set_unique_id(::google::protobuf::int32 value);

  // optional int32 left_point_index = 3;
  bool has_left_point_index() const;
  void clear_left_point_index();
  static const int kLeftPointIndexFieldNumber = 3;
  ::google::protobuf::int32 left_point_index() const;
  void set_left_point_index(::google::protobuf::int32 value);

  // optional int32 right_point_index = 4;
  bool has_right_point_index() const;
  void clear_right_point_index();
  static const int kRightPointIndexFieldNumber = 4;
  ::google::protobuf::int32 right_point_index() const;
  void set_right_point_index(::google::protobuf::int32 value);

  // optional .robosense.perception.Proto_msg.SizeType size_type = 6;
  bool has_size_type() const;
  void clear_size_type();
  static const int kSizeTypeFieldNumber = 6;
  ::robosense::perception::Proto_msg::SizeType size_type() const;
  void set_size_type(::robosense::perception::Proto_msg::SizeType value);

  // optional bool in_roi = 8;
  bool has_in_roi() const;
  void clear_in_roi();
  static const int kInRoiFieldNumber = 8;
  bool in_roi() const;
  void set_in_roi(bool value);

  // optional .robosense.perception.Proto_msg.TrackingState tracking_state = 9;
  bool has_tracking_state() const;
  void clear_tracking_state();
  static const int kTrackingStateFieldNumber = 9;
  ::robosense::perception::Proto_msg::TrackingState tracking_state() const;
  void set_tracking_state(::robosense::perception::Proto_msg::TrackingState value);

  // optional .robosense.perception.Proto_msg.GpsType gps_mode = 15;
  bool has_gps_mode() const;
  void clear_gps_mode();
  static const int kGpsModeFieldNumber = 15;
  ::robosense::perception::Proto_msg::GpsType gps_mode() const;
  void set_gps_mode(::robosense::perception::Proto_msg::GpsType value);

  // optional .robosense.perception.Proto_msg.ModeType mode = 7;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 7;
  ::robosense::perception::Proto_msg::ModeType mode() const;
  void set_mode(::robosense::perception::Proto_msg::ModeType value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.SupplementInfos)
 private:
  void set_has_unique_id();
  void clear_has_unique_id();
  void set_has_polygon();
  void clear_has_polygon();
  void set_has_left_point_index();
  void clear_has_left_point_index();
  void set_has_right_point_index();
  void clear_has_right_point_index();
  void set_has_latent_types();
  void clear_has_latent_types();
  void set_has_size_type();
  void clear_has_size_type();
  void set_has_mode();
  void clear_has_mode();
  void set_has_in_roi();
  void clear_has_in_roi();
  void set_has_tracking_state();
  void clear_has_tracking_state();
  void set_has_geo_center();
  void clear_has_geo_center();
  void set_has_geo_size();
  void clear_has_geo_size();
  void set_has_trajectory();
  void clear_has_trajectory();
  void set_has_history_velocity();
  void clear_has_history_velocity();
  void set_has_history_type();
  void clear_has_history_type();
  void set_has_gps_mode();
  void clear_has_gps_mode();
  void set_has_gps_info();
  void clear_has_gps_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::Vector3f* polygon_;
  ::robosense::perception::Proto_msg::Vector1f* latent_types_;
  ::robosense::perception::Proto_msg::Point3f* geo_center_;
  ::robosense::perception::Proto_msg::Point3f* geo_size_;
  ::robosense::perception::Proto_msg::Vector3f* trajectory_;
  ::robosense::perception::Proto_msg::Vector3f* history_velocity_;
  ::robosense::perception::Proto_msg::VectorObjType* history_type_;
  ::robosense::perception::Proto_msg::Point3d* gps_info_;
  ::google::protobuf::int32 unique_id_;
  ::google::protobuf::int32 left_point_index_;
  ::google::protobuf::int32 right_point_index_;
  int size_type_;
  bool in_roi_;
  int tracking_state_;
  int gps_mode_;
  int mode_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CoreInfos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.CoreInfos) */ {
 public:
  CoreInfos();
  virtual ~CoreInfos();

  CoreInfos(const CoreInfos& from);

  inline CoreInfos& operator=(const CoreInfos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoreInfos(CoreInfos&& from) noexcept
    : CoreInfos() {
    *this = ::std::move(from);
  }

  inline CoreInfos& operator=(CoreInfos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoreInfos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoreInfos* internal_default_instance() {
    return reinterpret_cast<const CoreInfos*>(
               &_CoreInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CoreInfos* other);
  friend void swap(CoreInfos& a, CoreInfos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoreInfos* New() const final {
    return CreateMaybeMessage<CoreInfos>(NULL);
  }

  CoreInfos* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoreInfos>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoreInfos& from);
  void MergeFrom(const CoreInfos& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoreInfos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.Point3f center = 4;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 4;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_center() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& center() const;
  ::robosense::perception::Proto_msg::Point3f* release_center();
  ::robosense::perception::Proto_msg::Point3f* mutable_center();
  void set_allocated_center(::robosense::perception::Proto_msg::Point3f* center);

  // optional .robosense.perception.Proto_msg.Point3f center_cov = 5;
  bool has_center_cov() const;
  void clear_center_cov();
  static const int kCenterCovFieldNumber = 5;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_center_cov() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& center_cov() const;
  ::robosense::perception::Proto_msg::Point3f* release_center_cov();
  ::robosense::perception::Proto_msg::Point3f* mutable_center_cov();
  void set_allocated_center_cov(::robosense::perception::Proto_msg::Point3f* center_cov);

  // optional .robosense.perception.Proto_msg.Point3f size = 6;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 6;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_size() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& size() const;
  ::robosense::perception::Proto_msg::Point3f* release_size();
  ::robosense::perception::Proto_msg::Point3f* mutable_size();
  void set_allocated_size(::robosense::perception::Proto_msg::Point3f* size);

  // optional .robosense.perception.Proto_msg.Point3f size_cov = 7;
  bool has_size_cov() const;
  void clear_size_cov();
  static const int kSizeCovFieldNumber = 7;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_size_cov() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& size_cov() const;
  ::robosense::perception::Proto_msg::Point3f* release_size_cov();
  ::robosense::perception::Proto_msg::Point3f* mutable_size_cov();
  void set_allocated_size_cov(::robosense::perception::Proto_msg::Point3f* size_cov);

  // optional .robosense.perception.Proto_msg.Point3f direction = 8;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 8;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_direction() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& direction() const;
  ::robosense::perception::Proto_msg::Point3f* release_direction();
  ::robosense::perception::Proto_msg::Point3f* mutable_direction();
  void set_allocated_direction(::robosense::perception::Proto_msg::Point3f* direction);

  // optional .robosense.perception.Proto_msg.Point3f direction_cov = 9;
  bool has_direction_cov() const;
  void clear_direction_cov();
  static const int kDirectionCovFieldNumber = 9;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_direction_cov() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& direction_cov() const;
  ::robosense::perception::Proto_msg::Point3f* release_direction_cov();
  ::robosense::perception::Proto_msg::Point3f* mutable_direction_cov();
  void set_allocated_direction_cov(::robosense::perception::Proto_msg::Point3f* direction_cov);

  // optional .robosense.perception.Proto_msg.Point3f velocity = 17;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 17;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_velocity() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& velocity() const;
  ::robosense::perception::Proto_msg::Point3f* release_velocity();
  ::robosense::perception::Proto_msg::Point3f* mutable_velocity();
  void set_allocated_velocity(::robosense::perception::Proto_msg::Point3f* velocity);

  // optional .robosense.perception.Proto_msg.Point3f velocity_cov = 18;
  bool has_velocity_cov() const;
  void clear_velocity_cov();
  static const int kVelocityCovFieldNumber = 18;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_velocity_cov() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& velocity_cov() const;
  ::robosense::perception::Proto_msg::Point3f* release_velocity_cov();
  ::robosense::perception::Proto_msg::Point3f* mutable_velocity_cov();
  void set_allocated_velocity_cov(::robosense::perception::Proto_msg::Point3f* velocity_cov);

  // optional .robosense.perception.Proto_msg.Point3f acceleration = 19;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 19;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_acceleration() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& acceleration() const;
  ::robosense::perception::Proto_msg::Point3f* release_acceleration();
  ::robosense::perception::Proto_msg::Point3f* mutable_acceleration();
  void set_allocated_acceleration(::robosense::perception::Proto_msg::Point3f* acceleration);

  // optional .robosense.perception.Proto_msg.Point3f acceleration_cov = 20;
  bool has_acceleration_cov() const;
  void clear_acceleration_cov();
  static const int kAccelerationCovFieldNumber = 20;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_acceleration_cov() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& acceleration_cov() const;
  ::robosense::perception::Proto_msg::Point3f* release_acceleration_cov();
  ::robosense::perception::Proto_msg::Point3f* mutable_acceleration_cov();
  void set_allocated_acceleration_cov(::robosense::perception::Proto_msg::Point3f* acceleration_cov);

  // optional .robosense.perception.Proto_msg.Point3f anchor = 25;
  bool has_anchor() const;
  void clear_anchor();
  static const int kAnchorFieldNumber = 25;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_anchor() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& anchor() const;
  ::robosense::perception::Proto_msg::Point3f* release_anchor();
  ::robosense::perception::Proto_msg::Point3f* mutable_anchor();
  void set_allocated_anchor(::robosense::perception::Proto_msg::Point3f* anchor);

  // optional .robosense.perception.Proto_msg.Point3f nearest_point = 26;
  bool has_nearest_point() const;
  void clear_nearest_point();
  static const int kNearestPointFieldNumber = 26;
  private:
  const ::robosense::perception::Proto_msg::Point3f& _internal_nearest_point() const;
  public:
  const ::robosense::perception::Proto_msg::Point3f& nearest_point() const;
  ::robosense::perception::Proto_msg::Point3f* release_nearest_point();
  ::robosense::perception::Proto_msg::Point3f* mutable_nearest_point();
  void set_allocated_nearest_point(::robosense::perception::Proto_msg::Point3f* nearest_point);

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // optional int32 priority_id = 2;
  bool has_priority_id() const;
  void clear_priority_id();
  static const int kPriorityIdFieldNumber = 2;
  ::google::protobuf::int32 priority_id() const;
  void set_priority_id(::google::protobuf::int32 value);

  // optional float existence_confidence = 3;
  bool has_existence_confidence() const;
  void clear_existence_confidence();
  static const int kExistenceConfidenceFieldNumber = 3;
  float existence_confidence() const;
  void set_existence_confidence(float value);

  // optional .robosense.perception.Proto_msg.ObjectType type = 10;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 10;
  ::robosense::perception::Proto_msg::ObjectType type() const;
  void set_type(::robosense::perception::Proto_msg::ObjectType value);

  // optional float type_confidence = 11;
  bool has_type_confidence() const;
  void clear_type_confidence();
  static const int kTypeConfidenceFieldNumber = 11;
  float type_confidence() const;
  void set_type_confidence(float value);

  // optional .robosense.perception.Proto_msg.AttentionType attention_type = 12;
  bool has_attention_type() const;
  void clear_attention_type();
  static const int kAttentionTypeFieldNumber = 12;
  ::robosense::perception::Proto_msg::AttentionType attention_type() const;
  void set_attention_type(::robosense::perception::Proto_msg::AttentionType value);

  // optional .robosense.perception.Proto_msg.MotionType motion_state = 13;
  bool has_motion_state() const;
  void clear_motion_state();
  static const int kMotionStateFieldNumber = 13;
  ::robosense::perception::Proto_msg::MotionType motion_state() const;
  void set_motion_state(::robosense::perception::Proto_msg::MotionType value);

  // optional double age = 16;
  bool has_age() const;
  void clear_age();
  static const int kAgeFieldNumber = 16;
  double age() const;
  void set_age(double value);

  // optional int32 tracker_id = 15;
  bool has_tracker_id() const;
  void clear_tracker_id();
  static const int kTrackerIdFieldNumber = 15;
  ::google::protobuf::int32 tracker_id() const;
  void set_tracker_id(::google::protobuf::int32 value);

  // optional float angle_velocity = 21;
  bool has_angle_velocity() const;
  void clear_angle_velocity();
  static const int kAngleVelocityFieldNumber = 21;
  float angle_velocity() const;
  void set_angle_velocity(float value);

  // optional float angle_velocity_cov = 22;
  bool has_angle_velocity_cov() const;
  void clear_angle_velocity_cov();
  static const int kAngleVelocityCovFieldNumber = 22;
  float angle_velocity_cov() const;
  void set_angle_velocity_cov(float value);

  // optional float angle_acceleration = 23;
  bool has_angle_acceleration() const;
  void clear_angle_acceleration();
  static const int kAngleAccelerationFieldNumber = 23;
  float angle_acceleration() const;
  void set_angle_acceleration(float value);

  // optional float angle_acceleration_cov = 24;
  bool has_angle_acceleration_cov() const;
  void clear_angle_acceleration_cov();
  static const int kAngleAccelerationCovFieldNumber = 24;
  float angle_acceleration_cov() const;
  void set_angle_acceleration_cov(float value);

  // optional .robosense.perception.Proto_msg.LanePosition lane_pos = 14;
  bool has_lane_pos() const;
  void clear_lane_pos();
  static const int kLanePosFieldNumber = 14;
  ::robosense::perception::Proto_msg::LanePosition lane_pos() const;
  void set_lane_pos(::robosense::perception::Proto_msg::LanePosition value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.CoreInfos)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_priority_id();
  void clear_has_priority_id();
  void set_has_existence_confidence();
  void clear_has_existence_confidence();
  void set_has_center();
  void clear_has_center();
  void set_has_center_cov();
  void clear_has_center_cov();
  void set_has_size();
  void clear_has_size();
  void set_has_size_cov();
  void clear_has_size_cov();
  void set_has_direction();
  void clear_has_direction();
  void set_has_direction_cov();
  void clear_has_direction_cov();
  void set_has_type();
  void clear_has_type();
  void set_has_type_confidence();
  void clear_has_type_confidence();
  void set_has_attention_type();
  void clear_has_attention_type();
  void set_has_motion_state();
  void clear_has_motion_state();
  void set_has_lane_pos();
  void clear_has_lane_pos();
  void set_has_tracker_id();
  void clear_has_tracker_id();
  void set_has_age();
  void clear_has_age();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_velocity_cov();
  void clear_has_velocity_cov();
  void set_has_acceleration();
  void clear_has_acceleration();
  void set_has_acceleration_cov();
  void clear_has_acceleration_cov();
  void set_has_angle_velocity();
  void clear_has_angle_velocity();
  void set_has_angle_velocity_cov();
  void clear_has_angle_velocity_cov();
  void set_has_angle_acceleration();
  void clear_has_angle_acceleration();
  void set_has_angle_acceleration_cov();
  void clear_has_angle_acceleration_cov();
  void set_has_anchor();
  void clear_has_anchor();
  void set_has_nearest_point();
  void clear_has_nearest_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::Point3f* center_;
  ::robosense::perception::Proto_msg::Point3f* center_cov_;
  ::robosense::perception::Proto_msg::Point3f* size_;
  ::robosense::perception::Proto_msg::Point3f* size_cov_;
  ::robosense::perception::Proto_msg::Point3f* direction_;
  ::robosense::perception::Proto_msg::Point3f* direction_cov_;
  ::robosense::perception::Proto_msg::Point3f* velocity_;
  ::robosense::perception::Proto_msg::Point3f* velocity_cov_;
  ::robosense::perception::Proto_msg::Point3f* acceleration_;
  ::robosense::perception::Proto_msg::Point3f* acceleration_cov_;
  ::robosense::perception::Proto_msg::Point3f* anchor_;
  ::robosense::perception::Proto_msg::Point3f* nearest_point_;
  double timestamp_;
  ::google::protobuf::int32 priority_id_;
  float existence_confidence_;
  int type_;
  float type_confidence_;
  int attention_type_;
  int motion_state_;
  double age_;
  ::google::protobuf::int32 tracker_id_;
  float angle_velocity_;
  float angle_velocity_cov_;
  float angle_acceleration_;
  float angle_acceleration_cov_;
  int lane_pos_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(Object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Object* other);
  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(NULL);
  }

  Object* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.CoreInfos core_infos = 2;
  bool has_core_infos() const;
  void clear_core_infos();
  static const int kCoreInfosFieldNumber = 2;
  private:
  const ::robosense::perception::Proto_msg::CoreInfos& _internal_core_infos() const;
  public:
  const ::robosense::perception::Proto_msg::CoreInfos& core_infos() const;
  ::robosense::perception::Proto_msg::CoreInfos* release_core_infos();
  ::robosense::perception::Proto_msg::CoreInfos* mutable_core_infos();
  void set_allocated_core_infos(::robosense::perception::Proto_msg::CoreInfos* core_infos);

  // optional .robosense.perception.Proto_msg.SupplementInfos supplement_infos = 3;
  bool has_supplement_infos() const;
  void clear_supplement_infos();
  static const int kSupplementInfosFieldNumber = 3;
  private:
  const ::robosense::perception::Proto_msg::SupplementInfos& _internal_supplement_infos() const;
  public:
  const ::robosense::perception::Proto_msg::SupplementInfos& supplement_infos() const;
  ::robosense::perception::Proto_msg::SupplementInfos* release_supplement_infos();
  ::robosense::perception::Proto_msg::SupplementInfos* mutable_supplement_infos();
  void set_allocated_supplement_infos(::robosense::perception::Proto_msg::SupplementInfos* supplement_infos);

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Object)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_core_infos();
  void clear_has_core_infos();
  void set_has_supplement_infos();
  void clear_has_supplement_infos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::CoreInfos* core_infos_;
  ::robosense::perception::Proto_msg::SupplementInfos* supplement_infos_;
  double timestamp_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndPoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.EndPoints) */ {
 public:
  EndPoints();
  virtual ~EndPoints();

  EndPoints(const EndPoints& from);

  inline EndPoints& operator=(const EndPoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndPoints(EndPoints&& from) noexcept
    : EndPoints() {
    *this = ::std::move(from);
  }

  inline EndPoints& operator=(EndPoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndPoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndPoints* internal_default_instance() {
    return reinterpret_cast<const EndPoints*>(
               &_EndPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(EndPoints* other);
  friend void swap(EndPoints& a, EndPoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndPoints* New() const final {
    return CreateMaybeMessage<EndPoints>(NULL);
  }

  EndPoints* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndPoints>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EndPoints& from);
  void MergeFrom(const EndPoints& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndPoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.Point2f start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  const ::robosense::perception::Proto_msg::Point2f& _internal_start() const;
  public:
  const ::robosense::perception::Proto_msg::Point2f& start() const;
  ::robosense::perception::Proto_msg::Point2f* release_start();
  ::robosense::perception::Proto_msg::Point2f* mutable_start();
  void set_allocated_start(::robosense::perception::Proto_msg::Point2f* start);

  // optional .robosense.perception.Proto_msg.Point2f end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  private:
  const ::robosense::perception::Proto_msg::Point2f& _internal_end() const;
  public:
  const ::robosense::perception::Proto_msg::Point2f& end() const;
  ::robosense::perception::Proto_msg::Point2f* release_end();
  ::robosense::perception::Proto_msg::Point2f* mutable_end();
  void set_allocated_end(::robosense::perception::Proto_msg::Point2f* end);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.EndPoints)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::Point2f* start_;
  ::robosense::perception::Proto_msg::Point2f* end_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Curve : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Curve) */ {
 public:
  Curve();
  virtual ~Curve();

  Curve(const Curve& from);

  inline Curve& operator=(const Curve& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Curve(Curve&& from) noexcept
    : Curve() {
    *this = ::std::move(from);
  }

  inline Curve& operator=(Curve&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Curve& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Curve* internal_default_instance() {
    return reinterpret_cast<const Curve*>(
               &_Curve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Curve* other);
  friend void swap(Curve& a, Curve& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Curve* New() const final {
    return CreateMaybeMessage<Curve>(NULL);
  }

  Curve* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Curve>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Curve& from);
  void MergeFrom(const Curve& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Curve* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x_start = 1;
  bool has_x_start() const;
  void clear_x_start();
  static const int kXStartFieldNumber = 1;
  float x_start() const;
  void set_x_start(float value);

  // optional float x_end = 2;
  bool has_x_end() const;
  void clear_x_end();
  static const int kXEndFieldNumber = 2;
  float x_end() const;
  void set_x_end(float value);

  // optional float a = 3;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 3;
  float a() const;
  void set_a(float value);

  // optional float b = 4;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 4;
  float b() const;
  void set_b(float value);

  // optional float c = 5;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 5;
  float c() const;
  void set_c(float value);

  // optional float d = 6;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 6;
  float d() const;
  void set_d(float value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Curve)
 private:
  void set_has_x_start();
  void clear_has_x_start();
  void set_has_x_end();
  void clear_has_x_end();
  void set_has_a();
  void clear_has_a();
  void set_has_b();
  void clear_has_b();
  void set_has_c();
  void clear_has_c();
  void set_has_d();
  void clear_has_d();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_start_;
  float x_end_;
  float a_;
  float b_;
  float c_;
  float d_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(NULL);
  }

  Lane* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.EndPoints end_point = 1;
  bool has_end_point() const;
  void clear_end_point();
  static const int kEndPointFieldNumber = 1;
  private:
  const ::robosense::perception::Proto_msg::EndPoints& _internal_end_point() const;
  public:
  const ::robosense::perception::Proto_msg::EndPoints& end_point() const;
  ::robosense::perception::Proto_msg::EndPoints* release_end_point();
  ::robosense::perception::Proto_msg::EndPoints* mutable_end_point();
  void set_allocated_end_point(::robosense::perception::Proto_msg::EndPoints* end_point);

  // optional .robosense.perception.Proto_msg.Curve curve = 4;
  bool has_curve() const;
  void clear_curve();
  static const int kCurveFieldNumber = 4;
  private:
  const ::robosense::perception::Proto_msg::Curve& _internal_curve() const;
  public:
  const ::robosense::perception::Proto_msg::Curve& curve() const;
  ::robosense::perception::Proto_msg::Curve* release_curve();
  ::robosense::perception::Proto_msg::Curve* mutable_curve();
  void set_allocated_curve(::robosense::perception::Proto_msg::Curve* curve);

  // optional .robosense.perception.Proto_msg.MeasureStatus measure_status = 2;
  bool has_measure_status() const;
  void clear_measure_status();
  static const int kMeasureStatusFieldNumber = 2;
  ::robosense::perception::Proto_msg::MeasureStatus measure_status() const;
  void set_measure_status(::robosense::perception::Proto_msg::MeasureStatus value);

  // optional float confidence = 5;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 5;
  float confidence() const;
  void set_confidence(float value);

  // optional .robosense.perception.Proto_msg.LanePosition lane_id = 3;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 3;
  ::robosense::perception::Proto_msg::LanePosition lane_id() const;
  void set_lane_id(::robosense::perception::Proto_msg::LanePosition value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Lane)
 private:
  void set_has_end_point();
  void clear_has_end_point();
  void set_has_measure_status();
  void clear_has_measure_status();
  void set_has_lane_id();
  void clear_has_lane_id();
  void set_has_curve();
  void clear_has_curve();
  void set_has_confidence();
  void clear_has_confidence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::EndPoints* end_point_;
  ::robosense::perception::Proto_msg::Curve* curve_;
  int measure_status_;
  float confidence_;
  int lane_id_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lanes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.Lanes) */ {
 public:
  Lanes();
  virtual ~Lanes();

  Lanes(const Lanes& from);

  inline Lanes& operator=(const Lanes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lanes(Lanes&& from) noexcept
    : Lanes() {
    *this = ::std::move(from);
  }

  inline Lanes& operator=(Lanes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lanes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lanes* internal_default_instance() {
    return reinterpret_cast<const Lanes*>(
               &_Lanes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Lanes* other);
  friend void swap(Lanes& a, Lanes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lanes* New() const final {
    return CreateMaybeMessage<Lanes>(NULL);
  }

  Lanes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lanes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lanes& from);
  void MergeFrom(const Lanes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lanes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robosense.perception.Proto_msg.Lane lanes = 2;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 2;
  ::robosense::perception::Proto_msg::Lane* mutable_lanes(int index);
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Lane >*
      mutable_lanes();
  const ::robosense::perception::Proto_msg::Lane& lanes(int index) const;
  ::robosense::perception::Proto_msg::Lane* add_lanes();
  const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Lane >&
      lanes() const;

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.Lanes)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Lane > lanes_;
  double timestamp_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadEdge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.RoadEdge) */ {
 public:
  RoadEdge();
  virtual ~RoadEdge();

  RoadEdge(const RoadEdge& from);

  inline RoadEdge& operator=(const RoadEdge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadEdge(RoadEdge&& from) noexcept
    : RoadEdge() {
    *this = ::std::move(from);
  }

  inline RoadEdge& operator=(RoadEdge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadEdge* internal_default_instance() {
    return reinterpret_cast<const RoadEdge*>(
               &_RoadEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(RoadEdge* other);
  friend void swap(RoadEdge& a, RoadEdge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadEdge* New() const final {
    return CreateMaybeMessage<RoadEdge>(NULL);
  }

  RoadEdge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadEdge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadEdge& from);
  void MergeFrom(const RoadEdge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadEdge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robosense.perception.Proto_msg.EndPoints end_points = 1;
  bool has_end_points() const;
  void clear_end_points();
  static const int kEndPointsFieldNumber = 1;
  private:
  const ::robosense::perception::Proto_msg::EndPoints& _internal_end_points() const;
  public:
  const ::robosense::perception::Proto_msg::EndPoints& end_points() const;
  ::robosense::perception::Proto_msg::EndPoints* release_end_points();
  ::robosense::perception::Proto_msg::EndPoints* mutable_end_points();
  void set_allocated_end_points(::robosense::perception::Proto_msg::EndPoints* end_points);

  // optional .robosense.perception.Proto_msg.Curve curve = 4;
  bool has_curve() const;
  void clear_curve();
  static const int kCurveFieldNumber = 4;
  private:
  const ::robosense::perception::Proto_msg::Curve& _internal_curve() const;
  public:
  const ::robosense::perception::Proto_msg::Curve& curve() const;
  ::robosense::perception::Proto_msg::Curve* release_curve();
  ::robosense::perception::Proto_msg::Curve* mutable_curve();
  void set_allocated_curve(::robosense::perception::Proto_msg::Curve* curve);

  // optional .robosense.perception.Proto_msg.MeasureStatus measure_status = 2;
  bool has_measure_status() const;
  void clear_measure_status();
  static const int kMeasureStatusFieldNumber = 2;
  ::robosense::perception::Proto_msg::MeasureStatus measure_status() const;
  void set_measure_status(::robosense::perception::Proto_msg::MeasureStatus value);

  // optional float confidence = 5;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 5;
  float confidence() const;
  void set_confidence(float value);

  // optional .robosense.perception.Proto_msg.RoadedgePosition roadedge_id = 3;
  bool has_roadedge_id() const;
  void clear_roadedge_id();
  static const int kRoadedgeIdFieldNumber = 3;
  ::robosense::perception::Proto_msg::RoadedgePosition roadedge_id() const;
  void set_roadedge_id(::robosense::perception::Proto_msg::RoadedgePosition value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.RoadEdge)
 private:
  void set_has_end_points();
  void clear_has_end_points();
  void set_has_measure_status();
  void clear_has_measure_status();
  void set_has_roadedge_id();
  void clear_has_roadedge_id();
  void set_has_curve();
  void clear_has_curve();
  void set_has_confidence();
  void clear_has_confidence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::robosense::perception::Proto_msg::EndPoints* end_points_;
  ::robosense::perception::Proto_msg::Curve* curve_;
  int measure_status_;
  float confidence_;
  int roadedge_id_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadEdges : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.RoadEdges) */ {
 public:
  RoadEdges();
  virtual ~RoadEdges();

  RoadEdges(const RoadEdges& from);

  inline RoadEdges& operator=(const RoadEdges& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadEdges(RoadEdges&& from) noexcept
    : RoadEdges() {
    *this = ::std::move(from);
  }

  inline RoadEdges& operator=(RoadEdges&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadEdges& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadEdges* internal_default_instance() {
    return reinterpret_cast<const RoadEdges*>(
               &_RoadEdges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RoadEdges* other);
  friend void swap(RoadEdges& a, RoadEdges& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadEdges* New() const final {
    return CreateMaybeMessage<RoadEdges>(NULL);
  }

  RoadEdges* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadEdges>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadEdges& from);
  void MergeFrom(const RoadEdges& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadEdges* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robosense.perception.Proto_msg.RoadEdge roadedges = 2;
  int roadedges_size() const;
  void clear_roadedges();
  static const int kRoadedgesFieldNumber = 2;
  ::robosense::perception::Proto_msg::RoadEdge* mutable_roadedges(int index);
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::RoadEdge >*
      mutable_roadedges();
  const ::robosense::perception::Proto_msg::RoadEdge& roadedges(int index) const;
  ::robosense::perception::Proto_msg::RoadEdge* add_roadedges();
  const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::RoadEdge >&
      roadedges() const;

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.RoadEdges)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::RoadEdge > roadedges_;
  double timestamp_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointCloud : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.PointCloud) */ {
 public:
  PointCloud();
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloud& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(PointCloud* other);
  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointCloud* New() const final {
    return CreateMaybeMessage<PointCloud>(NULL);
  }

  PointCloud* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointCloud>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointCloud* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robosense.perception.Proto_msg.PointXYZITL point = 2;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  ::robosense::perception::Proto_msg::PointXYZITL* mutable_point(int index);
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::PointXYZITL >*
      mutable_point();
  const ::robosense::perception::Proto_msg::PointXYZITL& point(int index) const;
  ::robosense::perception::Proto_msg::PointXYZITL* add_point();
  const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::PointXYZITL >&
      point() const;

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.PointCloud)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::PointXYZITL > point_;
  double timestamp_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robosense.perception.Proto_msg.MsgHeader) */ {
 public:
  MsgHeader();
  virtual ~MsgHeader();

  MsgHeader(const MsgHeader& from);

  inline MsgHeader& operator=(const MsgHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgHeader(MsgHeader&& from) noexcept
    : MsgHeader() {
    *this = ::std::move(from);
  }

  inline MsgHeader& operator=(MsgHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgHeader* internal_default_instance() {
    return reinterpret_cast<const MsgHeader*>(
               &_MsgHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(MsgHeader* other);
  friend void swap(MsgHeader& a, MsgHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgHeader* New() const final {
    return CreateMaybeMessage<MsgHeader>(NULL);
  }

  MsgHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MsgHeader& from);
  void MergeFrom(const MsgHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double msgTimestamps = 1;
  bool has_msgtimestamps() const;
  void clear_msgtimestamps();
  static const int kMsgTimestampsFieldNumber = 1;
  double msgtimestamps() const;
  void set_msgtimestamps(double value);

  // optional uint32 msgVersion = 2;
  bool has_msgversion() const;
  void clear_msgversion();
  static const int kMsgVersionFieldNumber = 2;
  ::google::protobuf::uint32 msgversion() const;
  void set_msgversion(::google::protobuf::uint32 value);

  // optional uint32 msgType = 3;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 3;
  ::google::protobuf::uint32 msgtype() const;
  void set_msgtype(::google::protobuf::uint32 value);

  // optional uint32 deviceId = 4;
  bool has_deviceid() const;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 4;
  ::google::protobuf::uint32 deviceid() const;
  void set_deviceid(::google::protobuf::uint32 value);

  // optional uint32 msgFrameId = 5;
  bool has_msgframeid() const;
  void clear_msgframeid();
  static const int kMsgFrameIdFieldNumber = 5;
  ::google::protobuf::uint32 msgframeid() const;
  void set_msgframeid(::google::protobuf::uint32 value);

  // optional uint32 msgTotalCnt = 6;
  bool has_msgtotalcnt() const;
  void clear_msgtotalcnt();
  static const int kMsgTotalCntFieldNumber = 6;
  ::google::protobuf::uint32 msgtotalcnt() const;
  void set_msgtotalcnt(::google::protobuf::uint32 value);

  // optional uint32 msgLocalCnt = 7;
  bool has_msglocalcnt() const;
  void clear_msglocalcnt();
  static const int kMsgLocalCntFieldNumber = 7;
  ::google::protobuf::uint32 msglocalcnt() const;
  void set_msglocalcnt(::google::protobuf::uint32 value);

  // optional uint32 msgLocalLen = 8;
  bool has_msglocallen() const;
  void clear_msglocallen();
  static const int kMsgLocalLenFieldNumber = 8;
  ::google::protobuf::uint32 msglocallen() const;
  void set_msglocallen(::google::protobuf::uint32 value);

  // optional uint32 msgIndex = 9;
  bool has_msgindex() const;
  void clear_msgindex();
  static const int kMsgIndexFieldNumber = 9;
  ::google::protobuf::uint32 msgindex() const;
  void set_msgindex(::google::protobuf::uint32 value);

  // optional uint32 msgTotalFragment = 10;
  bool has_msgtotalfragment() const;
  void clear_msgtotalfragment();
  static const int kMsgTotalFragmentFieldNumber = 10;
  ::google::protobuf::uint32 msgtotalfragment() const;
  void set_msgtotalfragment(::google::protobuf::uint32 value);

  // optional uint32 msgFragmentIndex = 11;
  bool has_msgfragmentindex() const;
  void clear_msgfragmentindex();
  static const int kMsgFragmentIndexFieldNumber = 11;
  ::google::protobuf::uint32 msgfragmentindex() const;
  void set_msgfragmentindex(::google::protobuf::uint32 value);

  // optional uint32 msgRes0 = 12;
  bool has_msgres0() const;
  void clear_msgres0();
  static const int kMsgRes0FieldNumber = 12;
  ::google::protobuf::uint32 msgres0() const;
  void set_msgres0(::google::protobuf::uint32 value);

  // optional uint32 msgCheck16 = 13;
  bool has_msgcheck16() const;
  void clear_msgcheck16();
  static const int kMsgCheck16FieldNumber = 13;
  ::google::protobuf::uint32 msgcheck16() const;
  void set_msgcheck16(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robosense.perception.Proto_msg.MsgHeader)
 private:
  void set_has_msgtimestamps();
  void clear_has_msgtimestamps();
  void set_has_msgversion();
  void clear_has_msgversion();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_deviceid();
  void clear_has_deviceid();
  void set_has_msgframeid();
  void clear_has_msgframeid();
  void set_has_msgtotalcnt();
  void clear_has_msgtotalcnt();
  void set_has_msglocalcnt();
  void clear_has_msglocalcnt();
  void set_has_msglocallen();
  void clear_has_msglocallen();
  void set_has_msgindex();
  void clear_has_msgindex();
  void set_has_msgtotalfragment();
  void clear_has_msgtotalfragment();
  void set_has_msgfragmentindex();
  void clear_has_msgfragmentindex();
  void set_has_msgres0();
  void clear_has_msgres0();
  void set_has_msgcheck16();
  void clear_has_msgcheck16();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double msgtimestamps_;
  ::google::protobuf::uint32 msgversion_;
  ::google::protobuf::uint32 msgtype_;
  ::google::protobuf::uint32 deviceid_;
  ::google::protobuf::uint32 msgframeid_;
  ::google::protobuf::uint32 msgtotalcnt_;
  ::google::protobuf::uint32 msglocalcnt_;
  ::google::protobuf::uint32 msglocallen_;
  ::google::protobuf::uint32 msgindex_;
  ::google::protobuf::uint32 msgtotalfragment_;
  ::google::protobuf::uint32 msgfragmentindex_;
  ::google::protobuf::uint32 msgres0_;
  ::google::protobuf::uint32 msgcheck16_;
  friend struct ::protobuf_Proto_5fmsg_2ePercept_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point2f

// repeated float data = 1;
inline int Point2f::data_size() const {
  return data_.size();
}
inline void Point2f::clear_data() {
  data_.Clear();
}
inline float Point2f::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Point2f.data)
  return data_.Get(index);
}
inline void Point2f::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Point2f.data)
}
inline void Point2f::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.Point2f.data)
}
inline const ::google::protobuf::RepeatedField< float >&
Point2f::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.Point2f.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
Point2f::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.Point2f.data)
  return &data_;
}

// -------------------------------------------------------------------

// Point3f

// repeated float data = 1;
inline int Point3f::data_size() const {
  return data_.size();
}
inline void Point3f::clear_data() {
  data_.Clear();
}
inline float Point3f::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Point3f.data)
  return data_.Get(index);
}
inline void Point3f::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Point3f.data)
}
inline void Point3f::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.Point3f.data)
}
inline const ::google::protobuf::RepeatedField< float >&
Point3f::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.Point3f.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
Point3f::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.Point3f.data)
  return &data_;
}

// -------------------------------------------------------------------

// Point3d

// repeated double data = 1;
inline int Point3d::data_size() const {
  return data_.size();
}
inline void Point3d::clear_data() {
  data_.Clear();
}
inline double Point3d::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Point3d.data)
  return data_.Get(index);
}
inline void Point3d::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Point3d.data)
}
inline void Point3d::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.Point3d.data)
}
inline const ::google::protobuf::RepeatedField< double >&
Point3d::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.Point3d.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
Point3d::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.Point3d.data)
  return &data_;
}

// -------------------------------------------------------------------

// PointXYZITL

// optional float x = 1;
inline bool PointXYZITL::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointXYZITL::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointXYZITL::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointXYZITL::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointXYZITL::x() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointXYZITL.x)
  return x_;
}
inline void PointXYZITL::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PointXYZITL.x)
}

// optional float y = 2;
inline bool PointXYZITL::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointXYZITL::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointXYZITL::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointXYZITL::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointXYZITL::y() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointXYZITL.y)
  return y_;
}
inline void PointXYZITL::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PointXYZITL.y)
}

// optional float z = 3;
inline bool PointXYZITL::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointXYZITL::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointXYZITL::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointXYZITL::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PointXYZITL::z() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointXYZITL.z)
  return z_;
}
inline void PointXYZITL::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PointXYZITL.z)
}

// optional uint32 intensity = 4;
inline bool PointXYZITL::has_intensity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointXYZITL::set_has_intensity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointXYZITL::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointXYZITL::clear_intensity() {
  intensity_ = 0u;
  clear_has_intensity();
}
inline ::google::protobuf::uint32 PointXYZITL::intensity() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointXYZITL.intensity)
  return intensity_;
}
inline void PointXYZITL::set_intensity(::google::protobuf::uint32 value) {
  set_has_intensity();
  intensity_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PointXYZITL.intensity)
}

// optional double timestamp = 5;
inline bool PointXYZITL::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PointXYZITL::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PointXYZITL::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PointXYZITL::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double PointXYZITL::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointXYZITL.timestamp)
  return timestamp_;
}
inline void PointXYZITL::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PointXYZITL.timestamp)
}

// optional int32 label = 6;
inline bool PointXYZITL::has_label() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PointXYZITL::set_has_label() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PointXYZITL::clear_has_label() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PointXYZITL::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 PointXYZITL::label() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointXYZITL.label)
  return label_;
}
inline void PointXYZITL::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PointXYZITL.label)
}

// -------------------------------------------------------------------

// Vector1i

// repeated int32 data = 1;
inline int Vector1i::data_size() const {
  return data_.size();
}
inline void Vector1i::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 Vector1i::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Vector1i.data)
  return data_.Get(index);
}
inline void Vector1i::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Vector1i.data)
}
inline void Vector1i::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.Vector1i.data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Vector1i::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.Vector1i.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Vector1i::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.Vector1i.data)
  return &data_;
}

// -------------------------------------------------------------------

// Vector1f

// repeated float data = 1;
inline int Vector1f::data_size() const {
  return data_.size();
}
inline void Vector1f::clear_data() {
  data_.Clear();
}
inline float Vector1f::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Vector1f.data)
  return data_.Get(index);
}
inline void Vector1f::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Vector1f.data)
}
inline void Vector1f::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.Vector1f.data)
}
inline const ::google::protobuf::RepeatedField< float >&
Vector1f::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.Vector1f.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
Vector1f::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.Vector1f.data)
  return &data_;
}

// -------------------------------------------------------------------

// Vector3f

// repeated .robosense.perception.Proto_msg.Point3f data = 1;
inline int Vector3f::data_size() const {
  return data_.size();
}
inline void Vector3f::clear_data() {
  data_.Clear();
}
inline ::robosense::perception::Proto_msg::Point3f* Vector3f::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.Vector3f.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Point3f >*
Vector3f::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.Vector3f.data)
  return &data_;
}
inline const ::robosense::perception::Proto_msg::Point3f& Vector3f::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Vector3f.data)
  return data_.Get(index);
}
inline ::robosense::perception::Proto_msg::Point3f* Vector3f::add_data() {
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.Vector3f.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Point3f >&
Vector3f::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.Vector3f.data)
  return data_;
}

// -------------------------------------------------------------------

// VectorObjType

// repeated .robosense.perception.Proto_msg.ObjectType data = 1;
inline int VectorObjType::data_size() const {
  return data_.size();
}
inline void VectorObjType::clear_data() {
  data_.Clear();
}
inline ::robosense::perception::Proto_msg::ObjectType VectorObjType::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.VectorObjType.data)
  return static_cast< ::robosense::perception::Proto_msg::ObjectType >(data_.Get(index));
}
inline void VectorObjType::set_data(int index, ::robosense::perception::Proto_msg::ObjectType value) {
  assert(::robosense::perception::Proto_msg::ObjectType_IsValid(value));
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.VectorObjType.data)
}
inline void VectorObjType::add_data(::robosense::perception::Proto_msg::ObjectType value) {
  assert(::robosense::perception::Proto_msg::ObjectType_IsValid(value));
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.VectorObjType.data)
}
inline const ::google::protobuf::RepeatedField<int>&
VectorObjType::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.VectorObjType.data)
  return data_;
}
inline ::google::protobuf::RepeatedField<int>*
VectorObjType::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.VectorObjType.data)
  return &data_;
}

// -------------------------------------------------------------------

// Pose

// optional float x = 1;
inline bool Pose::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Pose::x() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Pose.x)
  return x_;
}
inline void Pose::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Pose.x)
}

// optional float y = 2;
inline bool Pose::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Pose::y() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Pose.y)
  return y_;
}
inline void Pose::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Pose.y)
}

// optional float z = 3;
inline bool Pose::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pose::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pose::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pose::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Pose::z() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Pose.z)
  return z_;
}
inline void Pose::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Pose.z)
}

// optional float roll = 4;
inline bool Pose::has_roll() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pose::set_has_roll() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pose::clear_has_roll() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pose::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float Pose::roll() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Pose.roll)
  return roll_;
}
inline void Pose::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Pose.roll)
}

// optional float pitch = 5;
inline bool Pose::has_pitch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pose::set_has_pitch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pose::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pose::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float Pose::pitch() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Pose.pitch)
  return pitch_;
}
inline void Pose::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Pose.pitch)
}

// optional float yaw = 6;
inline bool Pose::has_yaw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pose::set_has_yaw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pose::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pose::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float Pose::yaw() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Pose.yaw)
  return yaw_;
}
inline void Pose::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Pose.yaw)
}

// -------------------------------------------------------------------

// PoseInfo

// optional double timestamp = 1;
inline bool PoseInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseInfo::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double PoseInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PoseInfo.timestamp)
  return timestamp_;
}
inline void PoseInfo::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PoseInfo.timestamp)
}

// optional .robosense.perception.Proto_msg.Pose pose = 2;
inline bool PoseInfo::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseInfo::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseInfo::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseInfo::clear_pose() {
  if (pose_ != NULL) pose_->Clear();
  clear_has_pose();
}
inline const ::robosense::perception::Proto_msg::Pose& PoseInfo::_internal_pose() const {
  return *pose_;
}
inline const ::robosense::perception::Proto_msg::Pose& PoseInfo::pose() const {
  const ::robosense::perception::Proto_msg::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PoseInfo.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Pose*>(
      &::robosense::perception::Proto_msg::_Pose_default_instance_);
}
inline ::robosense::perception::Proto_msg::Pose* PoseInfo::release_pose() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.PoseInfo.pose)
  clear_has_pose();
  ::robosense::perception::Proto_msg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Pose* PoseInfo::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.PoseInfo.pose)
  return pose_;
}
inline void PoseInfo::set_allocated_pose(::robosense::perception::Proto_msg::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_;
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    set_has_pose();
  } else {
    clear_has_pose();
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.PoseInfo.pose)
}

// -------------------------------------------------------------------

// VectorFreeSpaceType

// repeated .robosense.perception.Proto_msg.FreeSpaceType data = 1;
inline int VectorFreeSpaceType::data_size() const {
  return data_.size();
}
inline void VectorFreeSpaceType::clear_data() {
  data_.Clear();
}
inline ::robosense::perception::Proto_msg::FreeSpaceType VectorFreeSpaceType::data(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.VectorFreeSpaceType.data)
  return static_cast< ::robosense::perception::Proto_msg::FreeSpaceType >(data_.Get(index));
}
inline void VectorFreeSpaceType::set_data(int index, ::robosense::perception::Proto_msg::FreeSpaceType value) {
  assert(::robosense::perception::Proto_msg::FreeSpaceType_IsValid(value));
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.VectorFreeSpaceType.data)
}
inline void VectorFreeSpaceType::add_data(::robosense::perception::Proto_msg::FreeSpaceType value) {
  assert(::robosense::perception::Proto_msg::FreeSpaceType_IsValid(value));
  data_.Add(value);
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.VectorFreeSpaceType.data)
}
inline const ::google::protobuf::RepeatedField<int>&
VectorFreeSpaceType::data() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.VectorFreeSpaceType.data)
  return data_;
}
inline ::google::protobuf::RepeatedField<int>*
VectorFreeSpaceType::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.VectorFreeSpaceType.data)
  return &data_;
}

// -------------------------------------------------------------------

// FreeSpaces

// optional double timestamp = 1;
inline bool FreeSpaces::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FreeSpaces::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FreeSpaces::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FreeSpaces::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double FreeSpaces::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.FreeSpaces.timestamp)
  return timestamp_;
}
inline void FreeSpaces::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.FreeSpaces.timestamp)
}

// optional .robosense.perception.Proto_msg.Vector3f fs_pts = 2;
inline bool FreeSpaces::has_fs_pts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FreeSpaces::set_has_fs_pts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FreeSpaces::clear_has_fs_pts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FreeSpaces::clear_fs_pts() {
  if (fs_pts_ != NULL) fs_pts_->Clear();
  clear_has_fs_pts();
}
inline const ::robosense::perception::Proto_msg::Vector3f& FreeSpaces::_internal_fs_pts() const {
  return *fs_pts_;
}
inline const ::robosense::perception::Proto_msg::Vector3f& FreeSpaces::fs_pts() const {
  const ::robosense::perception::Proto_msg::Vector3f* p = fs_pts_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.FreeSpaces.fs_pts)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Vector3f*>(
      &::robosense::perception::Proto_msg::_Vector3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Vector3f* FreeSpaces::release_fs_pts() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.FreeSpaces.fs_pts)
  clear_has_fs_pts();
  ::robosense::perception::Proto_msg::Vector3f* temp = fs_pts_;
  fs_pts_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Vector3f* FreeSpaces::mutable_fs_pts() {
  set_has_fs_pts();
  if (fs_pts_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Vector3f>(GetArenaNoVirtual());
    fs_pts_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.FreeSpaces.fs_pts)
  return fs_pts_;
}
inline void FreeSpaces::set_allocated_fs_pts(::robosense::perception::Proto_msg::Vector3f* fs_pts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fs_pts_;
  }
  if (fs_pts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fs_pts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fs_pts, submessage_arena);
    }
    set_has_fs_pts();
  } else {
    clear_has_fs_pts();
  }
  fs_pts_ = fs_pts;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.FreeSpaces.fs_pts)
}

// optional .robosense.perception.Proto_msg.Vector1f fs_confidence = 3;
inline bool FreeSpaces::has_fs_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FreeSpaces::set_has_fs_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FreeSpaces::clear_has_fs_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FreeSpaces::clear_fs_confidence() {
  if (fs_confidence_ != NULL) fs_confidence_->Clear();
  clear_has_fs_confidence();
}
inline const ::robosense::perception::Proto_msg::Vector1f& FreeSpaces::_internal_fs_confidence() const {
  return *fs_confidence_;
}
inline const ::robosense::perception::Proto_msg::Vector1f& FreeSpaces::fs_confidence() const {
  const ::robosense::perception::Proto_msg::Vector1f* p = fs_confidence_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.FreeSpaces.fs_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Vector1f*>(
      &::robosense::perception::Proto_msg::_Vector1f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Vector1f* FreeSpaces::release_fs_confidence() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.FreeSpaces.fs_confidence)
  clear_has_fs_confidence();
  ::robosense::perception::Proto_msg::Vector1f* temp = fs_confidence_;
  fs_confidence_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Vector1f* FreeSpaces::mutable_fs_confidence() {
  set_has_fs_confidence();
  if (fs_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Vector1f>(GetArenaNoVirtual());
    fs_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.FreeSpaces.fs_confidence)
  return fs_confidence_;
}
inline void FreeSpaces::set_allocated_fs_confidence(::robosense::perception::Proto_msg::Vector1f* fs_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fs_confidence_;
  }
  if (fs_confidence) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fs_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fs_confidence, submessage_arena);
    }
    set_has_fs_confidence();
  } else {
    clear_has_fs_confidence();
  }
  fs_confidence_ = fs_confidence;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.FreeSpaces.fs_confidence)
}

// optional .robosense.perception.Proto_msg.VectorFreeSpaceType fs_types = 4;
inline bool FreeSpaces::has_fs_types() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FreeSpaces::set_has_fs_types() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FreeSpaces::clear_has_fs_types() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FreeSpaces::clear_fs_types() {
  if (fs_types_ != NULL) fs_types_->Clear();
  clear_has_fs_types();
}
inline const ::robosense::perception::Proto_msg::VectorFreeSpaceType& FreeSpaces::_internal_fs_types() const {
  return *fs_types_;
}
inline const ::robosense::perception::Proto_msg::VectorFreeSpaceType& FreeSpaces::fs_types() const {
  const ::robosense::perception::Proto_msg::VectorFreeSpaceType* p = fs_types_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.FreeSpaces.fs_types)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::VectorFreeSpaceType*>(
      &::robosense::perception::Proto_msg::_VectorFreeSpaceType_default_instance_);
}
inline ::robosense::perception::Proto_msg::VectorFreeSpaceType* FreeSpaces::release_fs_types() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.FreeSpaces.fs_types)
  clear_has_fs_types();
  ::robosense::perception::Proto_msg::VectorFreeSpaceType* temp = fs_types_;
  fs_types_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::VectorFreeSpaceType* FreeSpaces::mutable_fs_types() {
  set_has_fs_types();
  if (fs_types_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::VectorFreeSpaceType>(GetArenaNoVirtual());
    fs_types_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.FreeSpaces.fs_types)
  return fs_types_;
}
inline void FreeSpaces::set_allocated_fs_types(::robosense::perception::Proto_msg::VectorFreeSpaceType* fs_types) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fs_types_;
  }
  if (fs_types) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fs_types = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fs_types, submessage_arena);
    }
    set_has_fs_types();
  } else {
    clear_has_fs_types();
  }
  fs_types_ = fs_types;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.FreeSpaces.fs_types)
}

// -------------------------------------------------------------------

// SupplementInfos

// optional int32 unique_id = 1;
inline bool SupplementInfos::has_unique_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SupplementInfos::set_has_unique_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SupplementInfos::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SupplementInfos::clear_unique_id() {
  unique_id_ = 0;
  clear_has_unique_id();
}
inline ::google::protobuf::int32 SupplementInfos::unique_id() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.unique_id)
  return unique_id_;
}
inline void SupplementInfos::set_unique_id(::google::protobuf::int32 value) {
  set_has_unique_id();
  unique_id_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.unique_id)
}

// optional .robosense.perception.Proto_msg.Vector3f polygon = 2;
inline bool SupplementInfos::has_polygon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SupplementInfos::set_has_polygon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SupplementInfos::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SupplementInfos::clear_polygon() {
  if (polygon_ != NULL) polygon_->Clear();
  clear_has_polygon();
}
inline const ::robosense::perception::Proto_msg::Vector3f& SupplementInfos::_internal_polygon() const {
  return *polygon_;
}
inline const ::robosense::perception::Proto_msg::Vector3f& SupplementInfos::polygon() const {
  const ::robosense::perception::Proto_msg::Vector3f* p = polygon_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.polygon)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Vector3f*>(
      &::robosense::perception::Proto_msg::_Vector3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Vector3f* SupplementInfos::release_polygon() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.polygon)
  clear_has_polygon();
  ::robosense::perception::Proto_msg::Vector3f* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Vector3f* SupplementInfos::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Vector3f>(GetArenaNoVirtual());
    polygon_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.polygon)
  return polygon_;
}
inline void SupplementInfos::set_allocated_polygon(::robosense::perception::Proto_msg::Vector3f* polygon) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete polygon_;
  }
  if (polygon) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      polygon = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.polygon)
}

// optional int32 left_point_index = 3;
inline bool SupplementInfos::has_left_point_index() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SupplementInfos::set_has_left_point_index() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SupplementInfos::clear_has_left_point_index() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SupplementInfos::clear_left_point_index() {
  left_point_index_ = 0;
  clear_has_left_point_index();
}
inline ::google::protobuf::int32 SupplementInfos::left_point_index() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.left_point_index)
  return left_point_index_;
}
inline void SupplementInfos::set_left_point_index(::google::protobuf::int32 value) {
  set_has_left_point_index();
  left_point_index_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.left_point_index)
}

// optional int32 right_point_index = 4;
inline bool SupplementInfos::has_right_point_index() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SupplementInfos::set_has_right_point_index() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SupplementInfos::clear_has_right_point_index() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SupplementInfos::clear_right_point_index() {
  right_point_index_ = 0;
  clear_has_right_point_index();
}
inline ::google::protobuf::int32 SupplementInfos::right_point_index() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.right_point_index)
  return right_point_index_;
}
inline void SupplementInfos::set_right_point_index(::google::protobuf::int32 value) {
  set_has_right_point_index();
  right_point_index_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.right_point_index)
}

// optional .robosense.perception.Proto_msg.Vector1f latent_types = 5;
inline bool SupplementInfos::has_latent_types() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SupplementInfos::set_has_latent_types() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SupplementInfos::clear_has_latent_types() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SupplementInfos::clear_latent_types() {
  if (latent_types_ != NULL) latent_types_->Clear();
  clear_has_latent_types();
}
inline const ::robosense::perception::Proto_msg::Vector1f& SupplementInfos::_internal_latent_types() const {
  return *latent_types_;
}
inline const ::robosense::perception::Proto_msg::Vector1f& SupplementInfos::latent_types() const {
  const ::robosense::perception::Proto_msg::Vector1f* p = latent_types_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.latent_types)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Vector1f*>(
      &::robosense::perception::Proto_msg::_Vector1f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Vector1f* SupplementInfos::release_latent_types() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.latent_types)
  clear_has_latent_types();
  ::robosense::perception::Proto_msg::Vector1f* temp = latent_types_;
  latent_types_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Vector1f* SupplementInfos::mutable_latent_types() {
  set_has_latent_types();
  if (latent_types_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Vector1f>(GetArenaNoVirtual());
    latent_types_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.latent_types)
  return latent_types_;
}
inline void SupplementInfos::set_allocated_latent_types(::robosense::perception::Proto_msg::Vector1f* latent_types) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete latent_types_;
  }
  if (latent_types) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      latent_types = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, latent_types, submessage_arena);
    }
    set_has_latent_types();
  } else {
    clear_has_latent_types();
  }
  latent_types_ = latent_types;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.latent_types)
}

// optional .robosense.perception.Proto_msg.SizeType size_type = 6;
inline bool SupplementInfos::has_size_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SupplementInfos::set_has_size_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SupplementInfos::clear_has_size_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SupplementInfos::clear_size_type() {
  size_type_ = 0;
  clear_has_size_type();
}
inline ::robosense::perception::Proto_msg::SizeType SupplementInfos::size_type() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.size_type)
  return static_cast< ::robosense::perception::Proto_msg::SizeType >(size_type_);
}
inline void SupplementInfos::set_size_type(::robosense::perception::Proto_msg::SizeType value) {
  assert(::robosense::perception::Proto_msg::SizeType_IsValid(value));
  set_has_size_type();
  size_type_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.size_type)
}

// optional .robosense.perception.Proto_msg.ModeType mode = 7;
inline bool SupplementInfos::has_mode() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SupplementInfos::set_has_mode() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SupplementInfos::clear_has_mode() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SupplementInfos::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::robosense::perception::Proto_msg::ModeType SupplementInfos::mode() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.mode)
  return static_cast< ::robosense::perception::Proto_msg::ModeType >(mode_);
}
inline void SupplementInfos::set_mode(::robosense::perception::Proto_msg::ModeType value) {
  assert(::robosense::perception::Proto_msg::ModeType_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.mode)
}

// optional bool in_roi = 8;
inline bool SupplementInfos::has_in_roi() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SupplementInfos::set_has_in_roi() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SupplementInfos::clear_has_in_roi() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SupplementInfos::clear_in_roi() {
  in_roi_ = false;
  clear_has_in_roi();
}
inline bool SupplementInfos::in_roi() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.in_roi)
  return in_roi_;
}
inline void SupplementInfos::set_in_roi(bool value) {
  set_has_in_roi();
  in_roi_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.in_roi)
}

// optional .robosense.perception.Proto_msg.TrackingState tracking_state = 9;
inline bool SupplementInfos::has_tracking_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SupplementInfos::set_has_tracking_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SupplementInfos::clear_has_tracking_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SupplementInfos::clear_tracking_state() {
  tracking_state_ = 0;
  clear_has_tracking_state();
}
inline ::robosense::perception::Proto_msg::TrackingState SupplementInfos::tracking_state() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.tracking_state)
  return static_cast< ::robosense::perception::Proto_msg::TrackingState >(tracking_state_);
}
inline void SupplementInfos::set_tracking_state(::robosense::perception::Proto_msg::TrackingState value) {
  assert(::robosense::perception::Proto_msg::TrackingState_IsValid(value));
  set_has_tracking_state();
  tracking_state_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.tracking_state)
}

// optional .robosense.perception.Proto_msg.Point3f geo_center = 10;
inline bool SupplementInfos::has_geo_center() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SupplementInfos::set_has_geo_center() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SupplementInfos::clear_has_geo_center() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SupplementInfos::clear_geo_center() {
  if (geo_center_ != NULL) geo_center_->Clear();
  clear_has_geo_center();
}
inline const ::robosense::perception::Proto_msg::Point3f& SupplementInfos::_internal_geo_center() const {
  return *geo_center_;
}
inline const ::robosense::perception::Proto_msg::Point3f& SupplementInfos::geo_center() const {
  const ::robosense::perception::Proto_msg::Point3f* p = geo_center_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.geo_center)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* SupplementInfos::release_geo_center() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.geo_center)
  clear_has_geo_center();
  ::robosense::perception::Proto_msg::Point3f* temp = geo_center_;
  geo_center_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* SupplementInfos::mutable_geo_center() {
  set_has_geo_center();
  if (geo_center_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    geo_center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.geo_center)
  return geo_center_;
}
inline void SupplementInfos::set_allocated_geo_center(::robosense::perception::Proto_msg::Point3f* geo_center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geo_center_;
  }
  if (geo_center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geo_center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geo_center, submessage_arena);
    }
    set_has_geo_center();
  } else {
    clear_has_geo_center();
  }
  geo_center_ = geo_center;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.geo_center)
}

// optional .robosense.perception.Proto_msg.Point3f geo_size = 11;
inline bool SupplementInfos::has_geo_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SupplementInfos::set_has_geo_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SupplementInfos::clear_has_geo_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SupplementInfos::clear_geo_size() {
  if (geo_size_ != NULL) geo_size_->Clear();
  clear_has_geo_size();
}
inline const ::robosense::perception::Proto_msg::Point3f& SupplementInfos::_internal_geo_size() const {
  return *geo_size_;
}
inline const ::robosense::perception::Proto_msg::Point3f& SupplementInfos::geo_size() const {
  const ::robosense::perception::Proto_msg::Point3f* p = geo_size_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.geo_size)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* SupplementInfos::release_geo_size() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.geo_size)
  clear_has_geo_size();
  ::robosense::perception::Proto_msg::Point3f* temp = geo_size_;
  geo_size_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* SupplementInfos::mutable_geo_size() {
  set_has_geo_size();
  if (geo_size_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    geo_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.geo_size)
  return geo_size_;
}
inline void SupplementInfos::set_allocated_geo_size(::robosense::perception::Proto_msg::Point3f* geo_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geo_size_;
  }
  if (geo_size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geo_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geo_size, submessage_arena);
    }
    set_has_geo_size();
  } else {
    clear_has_geo_size();
  }
  geo_size_ = geo_size;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.geo_size)
}

// optional .robosense.perception.Proto_msg.Vector3f trajectory = 12;
inline bool SupplementInfos::has_trajectory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SupplementInfos::set_has_trajectory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SupplementInfos::clear_has_trajectory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SupplementInfos::clear_trajectory() {
  if (trajectory_ != NULL) trajectory_->Clear();
  clear_has_trajectory();
}
inline const ::robosense::perception::Proto_msg::Vector3f& SupplementInfos::_internal_trajectory() const {
  return *trajectory_;
}
inline const ::robosense::perception::Proto_msg::Vector3f& SupplementInfos::trajectory() const {
  const ::robosense::perception::Proto_msg::Vector3f* p = trajectory_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.trajectory)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Vector3f*>(
      &::robosense::perception::Proto_msg::_Vector3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Vector3f* SupplementInfos::release_trajectory() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.trajectory)
  clear_has_trajectory();
  ::robosense::perception::Proto_msg::Vector3f* temp = trajectory_;
  trajectory_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Vector3f* SupplementInfos::mutable_trajectory() {
  set_has_trajectory();
  if (trajectory_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Vector3f>(GetArenaNoVirtual());
    trajectory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.trajectory)
  return trajectory_;
}
inline void SupplementInfos::set_allocated_trajectory(::robosense::perception::Proto_msg::Vector3f* trajectory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_;
  }
  if (trajectory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory, submessage_arena);
    }
    set_has_trajectory();
  } else {
    clear_has_trajectory();
  }
  trajectory_ = trajectory;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.trajectory)
}

// optional .robosense.perception.Proto_msg.Vector3f history_velocity = 13;
inline bool SupplementInfos::has_history_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SupplementInfos::set_has_history_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SupplementInfos::clear_has_history_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SupplementInfos::clear_history_velocity() {
  if (history_velocity_ != NULL) history_velocity_->Clear();
  clear_has_history_velocity();
}
inline const ::robosense::perception::Proto_msg::Vector3f& SupplementInfos::_internal_history_velocity() const {
  return *history_velocity_;
}
inline const ::robosense::perception::Proto_msg::Vector3f& SupplementInfos::history_velocity() const {
  const ::robosense::perception::Proto_msg::Vector3f* p = history_velocity_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.history_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Vector3f*>(
      &::robosense::perception::Proto_msg::_Vector3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Vector3f* SupplementInfos::release_history_velocity() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.history_velocity)
  clear_has_history_velocity();
  ::robosense::perception::Proto_msg::Vector3f* temp = history_velocity_;
  history_velocity_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Vector3f* SupplementInfos::mutable_history_velocity() {
  set_has_history_velocity();
  if (history_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Vector3f>(GetArenaNoVirtual());
    history_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.history_velocity)
  return history_velocity_;
}
inline void SupplementInfos::set_allocated_history_velocity(::robosense::perception::Proto_msg::Vector3f* history_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete history_velocity_;
  }
  if (history_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      history_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, history_velocity, submessage_arena);
    }
    set_has_history_velocity();
  } else {
    clear_has_history_velocity();
  }
  history_velocity_ = history_velocity;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.history_velocity)
}

// optional .robosense.perception.Proto_msg.VectorObjType history_type = 14;
inline bool SupplementInfos::has_history_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SupplementInfos::set_has_history_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SupplementInfos::clear_has_history_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SupplementInfos::clear_history_type() {
  if (history_type_ != NULL) history_type_->Clear();
  clear_has_history_type();
}
inline const ::robosense::perception::Proto_msg::VectorObjType& SupplementInfos::_internal_history_type() const {
  return *history_type_;
}
inline const ::robosense::perception::Proto_msg::VectorObjType& SupplementInfos::history_type() const {
  const ::robosense::perception::Proto_msg::VectorObjType* p = history_type_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.history_type)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::VectorObjType*>(
      &::robosense::perception::Proto_msg::_VectorObjType_default_instance_);
}
inline ::robosense::perception::Proto_msg::VectorObjType* SupplementInfos::release_history_type() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.history_type)
  clear_has_history_type();
  ::robosense::perception::Proto_msg::VectorObjType* temp = history_type_;
  history_type_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::VectorObjType* SupplementInfos::mutable_history_type() {
  set_has_history_type();
  if (history_type_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::VectorObjType>(GetArenaNoVirtual());
    history_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.history_type)
  return history_type_;
}
inline void SupplementInfos::set_allocated_history_type(::robosense::perception::Proto_msg::VectorObjType* history_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete history_type_;
  }
  if (history_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      history_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, history_type, submessage_arena);
    }
    set_has_history_type();
  } else {
    clear_has_history_type();
  }
  history_type_ = history_type;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.history_type)
}

// optional .robosense.perception.Proto_msg.GpsType gps_mode = 15;
inline bool SupplementInfos::has_gps_mode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SupplementInfos::set_has_gps_mode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SupplementInfos::clear_has_gps_mode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SupplementInfos::clear_gps_mode() {
  gps_mode_ = 0;
  clear_has_gps_mode();
}
inline ::robosense::perception::Proto_msg::GpsType SupplementInfos::gps_mode() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.gps_mode)
  return static_cast< ::robosense::perception::Proto_msg::GpsType >(gps_mode_);
}
inline void SupplementInfos::set_gps_mode(::robosense::perception::Proto_msg::GpsType value) {
  assert(::robosense::perception::Proto_msg::GpsType_IsValid(value));
  set_has_gps_mode();
  gps_mode_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.SupplementInfos.gps_mode)
}

// optional .robosense.perception.Proto_msg.Point3d gps_info = 16;
inline bool SupplementInfos::has_gps_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SupplementInfos::set_has_gps_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SupplementInfos::clear_has_gps_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SupplementInfos::clear_gps_info() {
  if (gps_info_ != NULL) gps_info_->Clear();
  clear_has_gps_info();
}
inline const ::robosense::perception::Proto_msg::Point3d& SupplementInfos::_internal_gps_info() const {
  return *gps_info_;
}
inline const ::robosense::perception::Proto_msg::Point3d& SupplementInfos::gps_info() const {
  const ::robosense::perception::Proto_msg::Point3d* p = gps_info_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.SupplementInfos.gps_info)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3d*>(
      &::robosense::perception::Proto_msg::_Point3d_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3d* SupplementInfos::release_gps_info() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.SupplementInfos.gps_info)
  clear_has_gps_info();
  ::robosense::perception::Proto_msg::Point3d* temp = gps_info_;
  gps_info_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3d* SupplementInfos::mutable_gps_info() {
  set_has_gps_info();
  if (gps_info_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3d>(GetArenaNoVirtual());
    gps_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.SupplementInfos.gps_info)
  return gps_info_;
}
inline void SupplementInfos::set_allocated_gps_info(::robosense::perception::Proto_msg::Point3d* gps_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gps_info_;
  }
  if (gps_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gps_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gps_info, submessage_arena);
    }
    set_has_gps_info();
  } else {
    clear_has_gps_info();
  }
  gps_info_ = gps_info;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.SupplementInfos.gps_info)
}

// -------------------------------------------------------------------

// CoreInfos

// optional double timestamp = 1;
inline bool CoreInfos::has_timestamp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CoreInfos::set_has_timestamp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CoreInfos::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CoreInfos::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double CoreInfos::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.timestamp)
  return timestamp_;
}
inline void CoreInfos::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.timestamp)
}

// optional int32 priority_id = 2;
inline bool CoreInfos::has_priority_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CoreInfos::set_has_priority_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CoreInfos::clear_has_priority_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CoreInfos::clear_priority_id() {
  priority_id_ = 0;
  clear_has_priority_id();
}
inline ::google::protobuf::int32 CoreInfos::priority_id() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.priority_id)
  return priority_id_;
}
inline void CoreInfos::set_priority_id(::google::protobuf::int32 value) {
  set_has_priority_id();
  priority_id_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.priority_id)
}

// optional float existence_confidence = 3;
inline bool CoreInfos::has_existence_confidence() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CoreInfos::set_has_existence_confidence() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CoreInfos::clear_has_existence_confidence() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CoreInfos::clear_existence_confidence() {
  existence_confidence_ = 0;
  clear_has_existence_confidence();
}
inline float CoreInfos::existence_confidence() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.existence_confidence)
  return existence_confidence_;
}
inline void CoreInfos::set_existence_confidence(float value) {
  set_has_existence_confidence();
  existence_confidence_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.existence_confidence)
}

// optional .robosense.perception.Proto_msg.Point3f center = 4;
inline bool CoreInfos::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoreInfos::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoreInfos::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoreInfos::clear_center() {
  if (center_ != NULL) center_->Clear();
  clear_has_center();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_center() const {
  return *center_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::center() const {
  const ::robosense::perception::Proto_msg::Point3f* p = center_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.center)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_center() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.center)
  clear_has_center();
  ::robosense::perception::Proto_msg::Point3f* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.center)
  return center_;
}
inline void CoreInfos::set_allocated_center(::robosense::perception::Proto_msg::Point3f* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.center)
}

// optional .robosense.perception.Proto_msg.Point3f center_cov = 5;
inline bool CoreInfos::has_center_cov() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoreInfos::set_has_center_cov() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoreInfos::clear_has_center_cov() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoreInfos::clear_center_cov() {
  if (center_cov_ != NULL) center_cov_->Clear();
  clear_has_center_cov();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_center_cov() const {
  return *center_cov_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::center_cov() const {
  const ::robosense::perception::Proto_msg::Point3f* p = center_cov_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.center_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_center_cov() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.center_cov)
  clear_has_center_cov();
  ::robosense::perception::Proto_msg::Point3f* temp = center_cov_;
  center_cov_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_center_cov() {
  set_has_center_cov();
  if (center_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    center_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.center_cov)
  return center_cov_;
}
inline void CoreInfos::set_allocated_center_cov(::robosense::perception::Proto_msg::Point3f* center_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_cov_;
  }
  if (center_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center_cov, submessage_arena);
    }
    set_has_center_cov();
  } else {
    clear_has_center_cov();
  }
  center_cov_ = center_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.center_cov)
}

// optional .robosense.perception.Proto_msg.Point3f size = 6;
inline bool CoreInfos::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoreInfos::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoreInfos::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoreInfos::clear_size() {
  if (size_ != NULL) size_->Clear();
  clear_has_size();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_size() const {
  return *size_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::size() const {
  const ::robosense::perception::Proto_msg::Point3f* p = size_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.size)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_size() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.size)
  clear_has_size();
  ::robosense::perception::Proto_msg::Point3f* temp = size_;
  size_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_size() {
  set_has_size();
  if (size_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.size)
  return size_;
}
inline void CoreInfos::set_allocated_size(::robosense::perception::Proto_msg::Point3f* size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete size_;
  }
  if (size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    set_has_size();
  } else {
    clear_has_size();
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.size)
}

// optional .robosense.perception.Proto_msg.Point3f size_cov = 7;
inline bool CoreInfos::has_size_cov() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoreInfos::set_has_size_cov() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoreInfos::clear_has_size_cov() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoreInfos::clear_size_cov() {
  if (size_cov_ != NULL) size_cov_->Clear();
  clear_has_size_cov();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_size_cov() const {
  return *size_cov_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::size_cov() const {
  const ::robosense::perception::Proto_msg::Point3f* p = size_cov_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.size_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_size_cov() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.size_cov)
  clear_has_size_cov();
  ::robosense::perception::Proto_msg::Point3f* temp = size_cov_;
  size_cov_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_size_cov() {
  set_has_size_cov();
  if (size_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    size_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.size_cov)
  return size_cov_;
}
inline void CoreInfos::set_allocated_size_cov(::robosense::perception::Proto_msg::Point3f* size_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete size_cov_;
  }
  if (size_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      size_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size_cov, submessage_arena);
    }
    set_has_size_cov();
  } else {
    clear_has_size_cov();
  }
  size_cov_ = size_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.size_cov)
}

// optional .robosense.perception.Proto_msg.Point3f direction = 8;
inline bool CoreInfos::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CoreInfos::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CoreInfos::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CoreInfos::clear_direction() {
  if (direction_ != NULL) direction_->Clear();
  clear_has_direction();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_direction() const {
  return *direction_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::direction() const {
  const ::robosense::perception::Proto_msg::Point3f* p = direction_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.direction)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_direction() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.direction)
  clear_has_direction();
  ::robosense::perception::Proto_msg::Point3f* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    direction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.direction)
  return direction_;
}
inline void CoreInfos::set_allocated_direction(::robosense::perception::Proto_msg::Point3f* direction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete direction_;
  }
  if (direction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      direction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    set_has_direction();
  } else {
    clear_has_direction();
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.direction)
}

// optional .robosense.perception.Proto_msg.Point3f direction_cov = 9;
inline bool CoreInfos::has_direction_cov() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CoreInfos::set_has_direction_cov() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CoreInfos::clear_has_direction_cov() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CoreInfos::clear_direction_cov() {
  if (direction_cov_ != NULL) direction_cov_->Clear();
  clear_has_direction_cov();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_direction_cov() const {
  return *direction_cov_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::direction_cov() const {
  const ::robosense::perception::Proto_msg::Point3f* p = direction_cov_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.direction_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_direction_cov() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.direction_cov)
  clear_has_direction_cov();
  ::robosense::perception::Proto_msg::Point3f* temp = direction_cov_;
  direction_cov_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_direction_cov() {
  set_has_direction_cov();
  if (direction_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    direction_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.direction_cov)
  return direction_cov_;
}
inline void CoreInfos::set_allocated_direction_cov(::robosense::perception::Proto_msg::Point3f* direction_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete direction_cov_;
  }
  if (direction_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      direction_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, direction_cov, submessage_arena);
    }
    set_has_direction_cov();
  } else {
    clear_has_direction_cov();
  }
  direction_cov_ = direction_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.direction_cov)
}

// optional .robosense.perception.Proto_msg.ObjectType type = 10;
inline bool CoreInfos::has_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CoreInfos::set_has_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CoreInfos::clear_has_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CoreInfos::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::robosense::perception::Proto_msg::ObjectType CoreInfos::type() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.type)
  return static_cast< ::robosense::perception::Proto_msg::ObjectType >(type_);
}
inline void CoreInfos::set_type(::robosense::perception::Proto_msg::ObjectType value) {
  assert(::robosense::perception::Proto_msg::ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.type)
}

// optional float type_confidence = 11;
inline bool CoreInfos::has_type_confidence() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CoreInfos::set_has_type_confidence() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CoreInfos::clear_has_type_confidence() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CoreInfos::clear_type_confidence() {
  type_confidence_ = 0;
  clear_has_type_confidence();
}
inline float CoreInfos::type_confidence() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.type_confidence)
  return type_confidence_;
}
inline void CoreInfos::set_type_confidence(float value) {
  set_has_type_confidence();
  type_confidence_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.type_confidence)
}

// optional .robosense.perception.Proto_msg.AttentionType attention_type = 12;
inline bool CoreInfos::has_attention_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CoreInfos::set_has_attention_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CoreInfos::clear_has_attention_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CoreInfos::clear_attention_type() {
  attention_type_ = 0;
  clear_has_attention_type();
}
inline ::robosense::perception::Proto_msg::AttentionType CoreInfos::attention_type() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.attention_type)
  return static_cast< ::robosense::perception::Proto_msg::AttentionType >(attention_type_);
}
inline void CoreInfos::set_attention_type(::robosense::perception::Proto_msg::AttentionType value) {
  assert(::robosense::perception::Proto_msg::AttentionType_IsValid(value));
  set_has_attention_type();
  attention_type_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.attention_type)
}

// optional .robosense.perception.Proto_msg.MotionType motion_state = 13;
inline bool CoreInfos::has_motion_state() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CoreInfos::set_has_motion_state() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CoreInfos::clear_has_motion_state() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CoreInfos::clear_motion_state() {
  motion_state_ = 0;
  clear_has_motion_state();
}
inline ::robosense::perception::Proto_msg::MotionType CoreInfos::motion_state() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.motion_state)
  return static_cast< ::robosense::perception::Proto_msg::MotionType >(motion_state_);
}
inline void CoreInfos::set_motion_state(::robosense::perception::Proto_msg::MotionType value) {
  assert(::robosense::perception::Proto_msg::MotionType_IsValid(value));
  set_has_motion_state();
  motion_state_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.motion_state)
}

// optional .robosense.perception.Proto_msg.LanePosition lane_pos = 14;
inline bool CoreInfos::has_lane_pos() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CoreInfos::set_has_lane_pos() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CoreInfos::clear_has_lane_pos() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CoreInfos::clear_lane_pos() {
  lane_pos_ = 7;
  clear_has_lane_pos();
}
inline ::robosense::perception::Proto_msg::LanePosition CoreInfos::lane_pos() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.lane_pos)
  return static_cast< ::robosense::perception::Proto_msg::LanePosition >(lane_pos_);
}
inline void CoreInfos::set_lane_pos(::robosense::perception::Proto_msg::LanePosition value) {
  assert(::robosense::perception::Proto_msg::LanePosition_IsValid(value));
  set_has_lane_pos();
  lane_pos_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.lane_pos)
}

// optional int32 tracker_id = 15;
inline bool CoreInfos::has_tracker_id() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CoreInfos::set_has_tracker_id() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CoreInfos::clear_has_tracker_id() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CoreInfos::clear_tracker_id() {
  tracker_id_ = 0;
  clear_has_tracker_id();
}
inline ::google::protobuf::int32 CoreInfos::tracker_id() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.tracker_id)
  return tracker_id_;
}
inline void CoreInfos::set_tracker_id(::google::protobuf::int32 value) {
  set_has_tracker_id();
  tracker_id_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.tracker_id)
}

// optional double age = 16;
inline bool CoreInfos::has_age() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CoreInfos::set_has_age() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CoreInfos::clear_has_age() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CoreInfos::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline double CoreInfos::age() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.age)
  return age_;
}
inline void CoreInfos::set_age(double value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.age)
}

// optional .robosense.perception.Proto_msg.Point3f velocity = 17;
inline bool CoreInfos::has_velocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CoreInfos::set_has_velocity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CoreInfos::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CoreInfos::clear_velocity() {
  if (velocity_ != NULL) velocity_->Clear();
  clear_has_velocity();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_velocity() const {
  return *velocity_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::velocity() const {
  const ::robosense::perception::Proto_msg::Point3f* p = velocity_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_velocity() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.velocity)
  clear_has_velocity();
  ::robosense::perception::Proto_msg::Point3f* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.velocity)
  return velocity_;
}
inline void CoreInfos::set_allocated_velocity(::robosense::perception::Proto_msg::Point3f* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.velocity)
}

// optional .robosense.perception.Proto_msg.Point3f velocity_cov = 18;
inline bool CoreInfos::has_velocity_cov() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CoreInfos::set_has_velocity_cov() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CoreInfos::clear_has_velocity_cov() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CoreInfos::clear_velocity_cov() {
  if (velocity_cov_ != NULL) velocity_cov_->Clear();
  clear_has_velocity_cov();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_velocity_cov() const {
  return *velocity_cov_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::velocity_cov() const {
  const ::robosense::perception::Proto_msg::Point3f* p = velocity_cov_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.velocity_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_velocity_cov() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.velocity_cov)
  clear_has_velocity_cov();
  ::robosense::perception::Proto_msg::Point3f* temp = velocity_cov_;
  velocity_cov_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_velocity_cov() {
  set_has_velocity_cov();
  if (velocity_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    velocity_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.velocity_cov)
  return velocity_cov_;
}
inline void CoreInfos::set_allocated_velocity_cov(::robosense::perception::Proto_msg::Point3f* velocity_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_cov_;
  }
  if (velocity_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_cov, submessage_arena);
    }
    set_has_velocity_cov();
  } else {
    clear_has_velocity_cov();
  }
  velocity_cov_ = velocity_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.velocity_cov)
}

// optional .robosense.perception.Proto_msg.Point3f acceleration = 19;
inline bool CoreInfos::has_acceleration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CoreInfos::set_has_acceleration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CoreInfos::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CoreInfos::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->Clear();
  clear_has_acceleration();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_acceleration() const {
  return *acceleration_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::acceleration() const {
  const ::robosense::perception::Proto_msg::Point3f* p = acceleration_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_acceleration() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.acceleration)
  clear_has_acceleration();
  ::robosense::perception::Proto_msg::Point3f* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.acceleration)
  return acceleration_;
}
inline void CoreInfos::set_allocated_acceleration(::robosense::perception::Proto_msg::Point3f* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acceleration_;
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.acceleration)
}

// optional .robosense.perception.Proto_msg.Point3f acceleration_cov = 20;
inline bool CoreInfos::has_acceleration_cov() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CoreInfos::set_has_acceleration_cov() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CoreInfos::clear_has_acceleration_cov() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CoreInfos::clear_acceleration_cov() {
  if (acceleration_cov_ != NULL) acceleration_cov_->Clear();
  clear_has_acceleration_cov();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_acceleration_cov() const {
  return *acceleration_cov_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::acceleration_cov() const {
  const ::robosense::perception::Proto_msg::Point3f* p = acceleration_cov_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.acceleration_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_acceleration_cov() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.acceleration_cov)
  clear_has_acceleration_cov();
  ::robosense::perception::Proto_msg::Point3f* temp = acceleration_cov_;
  acceleration_cov_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_acceleration_cov() {
  set_has_acceleration_cov();
  if (acceleration_cov_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    acceleration_cov_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.acceleration_cov)
  return acceleration_cov_;
}
inline void CoreInfos::set_allocated_acceleration_cov(::robosense::perception::Proto_msg::Point3f* acceleration_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acceleration_cov_;
  }
  if (acceleration_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration_cov, submessage_arena);
    }
    set_has_acceleration_cov();
  } else {
    clear_has_acceleration_cov();
  }
  acceleration_cov_ = acceleration_cov;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.acceleration_cov)
}

// optional float angle_velocity = 21;
inline bool CoreInfos::has_angle_velocity() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CoreInfos::set_has_angle_velocity() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CoreInfos::clear_has_angle_velocity() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CoreInfos::clear_angle_velocity() {
  angle_velocity_ = 0;
  clear_has_angle_velocity();
}
inline float CoreInfos::angle_velocity() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.angle_velocity)
  return angle_velocity_;
}
inline void CoreInfos::set_angle_velocity(float value) {
  set_has_angle_velocity();
  angle_velocity_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.angle_velocity)
}

// optional float angle_velocity_cov = 22;
inline bool CoreInfos::has_angle_velocity_cov() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CoreInfos::set_has_angle_velocity_cov() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CoreInfos::clear_has_angle_velocity_cov() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CoreInfos::clear_angle_velocity_cov() {
  angle_velocity_cov_ = 0;
  clear_has_angle_velocity_cov();
}
inline float CoreInfos::angle_velocity_cov() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.angle_velocity_cov)
  return angle_velocity_cov_;
}
inline void CoreInfos::set_angle_velocity_cov(float value) {
  set_has_angle_velocity_cov();
  angle_velocity_cov_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.angle_velocity_cov)
}

// optional float angle_acceleration = 23;
inline bool CoreInfos::has_angle_acceleration() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CoreInfos::set_has_angle_acceleration() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CoreInfos::clear_has_angle_acceleration() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CoreInfos::clear_angle_acceleration() {
  angle_acceleration_ = 0;
  clear_has_angle_acceleration();
}
inline float CoreInfos::angle_acceleration() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.angle_acceleration)
  return angle_acceleration_;
}
inline void CoreInfos::set_angle_acceleration(float value) {
  set_has_angle_acceleration();
  angle_acceleration_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.angle_acceleration)
}

// optional float angle_acceleration_cov = 24;
inline bool CoreInfos::has_angle_acceleration_cov() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CoreInfos::set_has_angle_acceleration_cov() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CoreInfos::clear_has_angle_acceleration_cov() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CoreInfos::clear_angle_acceleration_cov() {
  angle_acceleration_cov_ = 0;
  clear_has_angle_acceleration_cov();
}
inline float CoreInfos::angle_acceleration_cov() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.angle_acceleration_cov)
  return angle_acceleration_cov_;
}
inline void CoreInfos::set_angle_acceleration_cov(float value) {
  set_has_angle_acceleration_cov();
  angle_acceleration_cov_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.CoreInfos.angle_acceleration_cov)
}

// optional .robosense.perception.Proto_msg.Point3f anchor = 25;
inline bool CoreInfos::has_anchor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CoreInfos::set_has_anchor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CoreInfos::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CoreInfos::clear_anchor() {
  if (anchor_ != NULL) anchor_->Clear();
  clear_has_anchor();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_anchor() const {
  return *anchor_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::anchor() const {
  const ::robosense::perception::Proto_msg::Point3f* p = anchor_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.anchor)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_anchor() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.anchor)
  clear_has_anchor();
  ::robosense::perception::Proto_msg::Point3f* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    anchor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.anchor)
  return anchor_;
}
inline void CoreInfos::set_allocated_anchor(::robosense::perception::Proto_msg::Point3f* anchor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete anchor_;
  }
  if (anchor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      anchor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, anchor, submessage_arena);
    }
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
  anchor_ = anchor;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.anchor)
}

// optional .robosense.perception.Proto_msg.Point3f nearest_point = 26;
inline bool CoreInfos::has_nearest_point() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CoreInfos::set_has_nearest_point() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CoreInfos::clear_has_nearest_point() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CoreInfos::clear_nearest_point() {
  if (nearest_point_ != NULL) nearest_point_->Clear();
  clear_has_nearest_point();
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::_internal_nearest_point() const {
  return *nearest_point_;
}
inline const ::robosense::perception::Proto_msg::Point3f& CoreInfos::nearest_point() const {
  const ::robosense::perception::Proto_msg::Point3f* p = nearest_point_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.CoreInfos.nearest_point)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point3f*>(
      &::robosense::perception::Proto_msg::_Point3f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::release_nearest_point() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.CoreInfos.nearest_point)
  clear_has_nearest_point();
  ::robosense::perception::Proto_msg::Point3f* temp = nearest_point_;
  nearest_point_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point3f* CoreInfos::mutable_nearest_point() {
  set_has_nearest_point();
  if (nearest_point_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point3f>(GetArenaNoVirtual());
    nearest_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.CoreInfos.nearest_point)
  return nearest_point_;
}
inline void CoreInfos::set_allocated_nearest_point(::robosense::perception::Proto_msg::Point3f* nearest_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete nearest_point_;
  }
  if (nearest_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nearest_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nearest_point, submessage_arena);
    }
    set_has_nearest_point();
  } else {
    clear_has_nearest_point();
  }
  nearest_point_ = nearest_point;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.CoreInfos.nearest_point)
}

// -------------------------------------------------------------------

// Object

// optional double timestamp = 1;
inline bool Object::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Object::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Object::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Object::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Object::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Object.timestamp)
  return timestamp_;
}
inline void Object::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Object.timestamp)
}

// optional .robosense.perception.Proto_msg.CoreInfos core_infos = 2;
inline bool Object::has_core_infos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object::set_has_core_infos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object::clear_has_core_infos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object::clear_core_infos() {
  if (core_infos_ != NULL) core_infos_->Clear();
  clear_has_core_infos();
}
inline const ::robosense::perception::Proto_msg::CoreInfos& Object::_internal_core_infos() const {
  return *core_infos_;
}
inline const ::robosense::perception::Proto_msg::CoreInfos& Object::core_infos() const {
  const ::robosense::perception::Proto_msg::CoreInfos* p = core_infos_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Object.core_infos)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::CoreInfos*>(
      &::robosense::perception::Proto_msg::_CoreInfos_default_instance_);
}
inline ::robosense::perception::Proto_msg::CoreInfos* Object::release_core_infos() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.Object.core_infos)
  clear_has_core_infos();
  ::robosense::perception::Proto_msg::CoreInfos* temp = core_infos_;
  core_infos_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::CoreInfos* Object::mutable_core_infos() {
  set_has_core_infos();
  if (core_infos_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::CoreInfos>(GetArenaNoVirtual());
    core_infos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.Object.core_infos)
  return core_infos_;
}
inline void Object::set_allocated_core_infos(::robosense::perception::Proto_msg::CoreInfos* core_infos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete core_infos_;
  }
  if (core_infos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      core_infos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, core_infos, submessage_arena);
    }
    set_has_core_infos();
  } else {
    clear_has_core_infos();
  }
  core_infos_ = core_infos;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.Object.core_infos)
}

// optional .robosense.perception.Proto_msg.SupplementInfos supplement_infos = 3;
inline bool Object::has_supplement_infos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object::set_has_supplement_infos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object::clear_has_supplement_infos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object::clear_supplement_infos() {
  if (supplement_infos_ != NULL) supplement_infos_->Clear();
  clear_has_supplement_infos();
}
inline const ::robosense::perception::Proto_msg::SupplementInfos& Object::_internal_supplement_infos() const {
  return *supplement_infos_;
}
inline const ::robosense::perception::Proto_msg::SupplementInfos& Object::supplement_infos() const {
  const ::robosense::perception::Proto_msg::SupplementInfos* p = supplement_infos_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Object.supplement_infos)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::SupplementInfos*>(
      &::robosense::perception::Proto_msg::_SupplementInfos_default_instance_);
}
inline ::robosense::perception::Proto_msg::SupplementInfos* Object::release_supplement_infos() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.Object.supplement_infos)
  clear_has_supplement_infos();
  ::robosense::perception::Proto_msg::SupplementInfos* temp = supplement_infos_;
  supplement_infos_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::SupplementInfos* Object::mutable_supplement_infos() {
  set_has_supplement_infos();
  if (supplement_infos_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::SupplementInfos>(GetArenaNoVirtual());
    supplement_infos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.Object.supplement_infos)
  return supplement_infos_;
}
inline void Object::set_allocated_supplement_infos(::robosense::perception::Proto_msg::SupplementInfos* supplement_infos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete supplement_infos_;
  }
  if (supplement_infos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      supplement_infos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supplement_infos, submessage_arena);
    }
    set_has_supplement_infos();
  } else {
    clear_has_supplement_infos();
  }
  supplement_infos_ = supplement_infos;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.Object.supplement_infos)
}

// -------------------------------------------------------------------

// EndPoints

// optional .robosense.perception.Proto_msg.Point2f start = 1;
inline bool EndPoints::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndPoints::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndPoints::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndPoints::clear_start() {
  if (start_ != NULL) start_->Clear();
  clear_has_start();
}
inline const ::robosense::perception::Proto_msg::Point2f& EndPoints::_internal_start() const {
  return *start_;
}
inline const ::robosense::perception::Proto_msg::Point2f& EndPoints::start() const {
  const ::robosense::perception::Proto_msg::Point2f* p = start_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.EndPoints.start)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point2f*>(
      &::robosense::perception::Proto_msg::_Point2f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point2f* EndPoints::release_start() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.EndPoints.start)
  clear_has_start();
  ::robosense::perception::Proto_msg::Point2f* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point2f* EndPoints::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point2f>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.EndPoints.start)
  return start_;
}
inline void EndPoints::set_allocated_start(::robosense::perception::Proto_msg::Point2f* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    set_has_start();
  } else {
    clear_has_start();
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.EndPoints.start)
}

// optional .robosense.perception.Proto_msg.Point2f end = 2;
inline bool EndPoints::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndPoints::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndPoints::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndPoints::clear_end() {
  if (end_ != NULL) end_->Clear();
  clear_has_end();
}
inline const ::robosense::perception::Proto_msg::Point2f& EndPoints::_internal_end() const {
  return *end_;
}
inline const ::robosense::perception::Proto_msg::Point2f& EndPoints::end() const {
  const ::robosense::perception::Proto_msg::Point2f* p = end_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.EndPoints.end)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Point2f*>(
      &::robosense::perception::Proto_msg::_Point2f_default_instance_);
}
inline ::robosense::perception::Proto_msg::Point2f* EndPoints::release_end() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.EndPoints.end)
  clear_has_end();
  ::robosense::perception::Proto_msg::Point2f* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Point2f* EndPoints::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Point2f>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.EndPoints.end)
  return end_;
}
inline void EndPoints::set_allocated_end(::robosense::perception::Proto_msg::Point2f* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    set_has_end();
  } else {
    clear_has_end();
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.EndPoints.end)
}

// -------------------------------------------------------------------

// Curve

// optional float x_start = 1;
inline bool Curve::has_x_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Curve::set_has_x_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Curve::clear_has_x_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Curve::clear_x_start() {
  x_start_ = 0;
  clear_has_x_start();
}
inline float Curve::x_start() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Curve.x_start)
  return x_start_;
}
inline void Curve::set_x_start(float value) {
  set_has_x_start();
  x_start_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Curve.x_start)
}

// optional float x_end = 2;
inline bool Curve::has_x_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Curve::set_has_x_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Curve::clear_has_x_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Curve::clear_x_end() {
  x_end_ = 0;
  clear_has_x_end();
}
inline float Curve::x_end() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Curve.x_end)
  return x_end_;
}
inline void Curve::set_x_end(float value) {
  set_has_x_end();
  x_end_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Curve.x_end)
}

// optional float a = 3;
inline bool Curve::has_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Curve::set_has_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Curve::clear_has_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Curve::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline float Curve::a() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Curve.a)
  return a_;
}
inline void Curve::set_a(float value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Curve.a)
}

// optional float b = 4;
inline bool Curve::has_b() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Curve::set_has_b() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Curve::clear_has_b() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Curve::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float Curve::b() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Curve.b)
  return b_;
}
inline void Curve::set_b(float value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Curve.b)
}

// optional float c = 5;
inline bool Curve::has_c() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Curve::set_has_c() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Curve::clear_has_c() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Curve::clear_c() {
  c_ = 0;
  clear_has_c();
}
inline float Curve::c() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Curve.c)
  return c_;
}
inline void Curve::set_c(float value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Curve.c)
}

// optional float d = 6;
inline bool Curve::has_d() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Curve::set_has_d() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Curve::clear_has_d() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Curve::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline float Curve::d() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Curve.d)
  return d_;
}
inline void Curve::set_d(float value) {
  set_has_d();
  d_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Curve.d)
}

// -------------------------------------------------------------------

// Lane

// optional .robosense.perception.Proto_msg.EndPoints end_point = 1;
inline bool Lane::has_end_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lane::set_has_end_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lane::clear_has_end_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lane::clear_end_point() {
  if (end_point_ != NULL) end_point_->Clear();
  clear_has_end_point();
}
inline const ::robosense::perception::Proto_msg::EndPoints& Lane::_internal_end_point() const {
  return *end_point_;
}
inline const ::robosense::perception::Proto_msg::EndPoints& Lane::end_point() const {
  const ::robosense::perception::Proto_msg::EndPoints* p = end_point_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Lane.end_point)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::EndPoints*>(
      &::robosense::perception::Proto_msg::_EndPoints_default_instance_);
}
inline ::robosense::perception::Proto_msg::EndPoints* Lane::release_end_point() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.Lane.end_point)
  clear_has_end_point();
  ::robosense::perception::Proto_msg::EndPoints* temp = end_point_;
  end_point_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::EndPoints* Lane::mutable_end_point() {
  set_has_end_point();
  if (end_point_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::EndPoints>(GetArenaNoVirtual());
    end_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.Lane.end_point)
  return end_point_;
}
inline void Lane::set_allocated_end_point(::robosense::perception::Proto_msg::EndPoints* end_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_point_;
  }
  if (end_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_point, submessage_arena);
    }
    set_has_end_point();
  } else {
    clear_has_end_point();
  }
  end_point_ = end_point;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.Lane.end_point)
}

// optional .robosense.perception.Proto_msg.MeasureStatus measure_status = 2;
inline bool Lane::has_measure_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lane::set_has_measure_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lane::clear_has_measure_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lane::clear_measure_status() {
  measure_status_ = 0;
  clear_has_measure_status();
}
inline ::robosense::perception::Proto_msg::MeasureStatus Lane::measure_status() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Lane.measure_status)
  return static_cast< ::robosense::perception::Proto_msg::MeasureStatus >(measure_status_);
}
inline void Lane::set_measure_status(::robosense::perception::Proto_msg::MeasureStatus value) {
  assert(::robosense::perception::Proto_msg::MeasureStatus_IsValid(value));
  set_has_measure_status();
  measure_status_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Lane.measure_status)
}

// optional .robosense.perception.Proto_msg.LanePosition lane_id = 3;
inline bool Lane::has_lane_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Lane::set_has_lane_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Lane::clear_has_lane_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Lane::clear_lane_id() {
  lane_id_ = 7;
  clear_has_lane_id();
}
inline ::robosense::perception::Proto_msg::LanePosition Lane::lane_id() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Lane.lane_id)
  return static_cast< ::robosense::perception::Proto_msg::LanePosition >(lane_id_);
}
inline void Lane::set_lane_id(::robosense::perception::Proto_msg::LanePosition value) {
  assert(::robosense::perception::Proto_msg::LanePosition_IsValid(value));
  set_has_lane_id();
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Lane.lane_id)
}

// optional .robosense.perception.Proto_msg.Curve curve = 4;
inline bool Lane::has_curve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lane::set_has_curve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lane::clear_has_curve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lane::clear_curve() {
  if (curve_ != NULL) curve_->Clear();
  clear_has_curve();
}
inline const ::robosense::perception::Proto_msg::Curve& Lane::_internal_curve() const {
  return *curve_;
}
inline const ::robosense::perception::Proto_msg::Curve& Lane::curve() const {
  const ::robosense::perception::Proto_msg::Curve* p = curve_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Lane.curve)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Curve*>(
      &::robosense::perception::Proto_msg::_Curve_default_instance_);
}
inline ::robosense::perception::Proto_msg::Curve* Lane::release_curve() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.Lane.curve)
  clear_has_curve();
  ::robosense::perception::Proto_msg::Curve* temp = curve_;
  curve_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Curve* Lane::mutable_curve() {
  set_has_curve();
  if (curve_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Curve>(GetArenaNoVirtual());
    curve_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.Lane.curve)
  return curve_;
}
inline void Lane::set_allocated_curve(::robosense::perception::Proto_msg::Curve* curve) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete curve_;
  }
  if (curve) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      curve = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, curve, submessage_arena);
    }
    set_has_curve();
  } else {
    clear_has_curve();
  }
  curve_ = curve;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.Lane.curve)
}

// optional float confidence = 5;
inline bool Lane::has_confidence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Lane::set_has_confidence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Lane::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Lane::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float Lane::confidence() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Lane.confidence)
  return confidence_;
}
inline void Lane::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Lane.confidence)
}

// -------------------------------------------------------------------

// Lanes

// optional double timestamp = 1;
inline bool Lanes::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lanes::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lanes::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lanes::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Lanes::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Lanes.timestamp)
  return timestamp_;
}
inline void Lanes::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.Lanes.timestamp)
}

// repeated .robosense.perception.Proto_msg.Lane lanes = 2;
inline int Lanes::lanes_size() const {
  return lanes_.size();
}
inline void Lanes::clear_lanes() {
  lanes_.Clear();
}
inline ::robosense::perception::Proto_msg::Lane* Lanes::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.Lanes.lanes)
  return lanes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Lane >*
Lanes::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.Lanes.lanes)
  return &lanes_;
}
inline const ::robosense::perception::Proto_msg::Lane& Lanes::lanes(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.Lanes.lanes)
  return lanes_.Get(index);
}
inline ::robosense::perception::Proto_msg::Lane* Lanes::add_lanes() {
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.Lanes.lanes)
  return lanes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::Lane >&
Lanes::lanes() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.Lanes.lanes)
  return lanes_;
}

// -------------------------------------------------------------------

// RoadEdge

// optional .robosense.perception.Proto_msg.EndPoints end_points = 1;
inline bool RoadEdge::has_end_points() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadEdge::set_has_end_points() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadEdge::clear_has_end_points() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadEdge::clear_end_points() {
  if (end_points_ != NULL) end_points_->Clear();
  clear_has_end_points();
}
inline const ::robosense::perception::Proto_msg::EndPoints& RoadEdge::_internal_end_points() const {
  return *end_points_;
}
inline const ::robosense::perception::Proto_msg::EndPoints& RoadEdge::end_points() const {
  const ::robosense::perception::Proto_msg::EndPoints* p = end_points_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.RoadEdge.end_points)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::EndPoints*>(
      &::robosense::perception::Proto_msg::_EndPoints_default_instance_);
}
inline ::robosense::perception::Proto_msg::EndPoints* RoadEdge::release_end_points() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.RoadEdge.end_points)
  clear_has_end_points();
  ::robosense::perception::Proto_msg::EndPoints* temp = end_points_;
  end_points_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::EndPoints* RoadEdge::mutable_end_points() {
  set_has_end_points();
  if (end_points_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::EndPoints>(GetArenaNoVirtual());
    end_points_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.RoadEdge.end_points)
  return end_points_;
}
inline void RoadEdge::set_allocated_end_points(::robosense::perception::Proto_msg::EndPoints* end_points) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_points_;
  }
  if (end_points) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end_points = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_points, submessage_arena);
    }
    set_has_end_points();
  } else {
    clear_has_end_points();
  }
  end_points_ = end_points;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.RoadEdge.end_points)
}

// optional .robosense.perception.Proto_msg.MeasureStatus measure_status = 2;
inline bool RoadEdge::has_measure_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoadEdge::set_has_measure_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoadEdge::clear_has_measure_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoadEdge::clear_measure_status() {
  measure_status_ = 0;
  clear_has_measure_status();
}
inline ::robosense::perception::Proto_msg::MeasureStatus RoadEdge::measure_status() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.RoadEdge.measure_status)
  return static_cast< ::robosense::perception::Proto_msg::MeasureStatus >(measure_status_);
}
inline void RoadEdge::set_measure_status(::robosense::perception::Proto_msg::MeasureStatus value) {
  assert(::robosense::perception::Proto_msg::MeasureStatus_IsValid(value));
  set_has_measure_status();
  measure_status_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.RoadEdge.measure_status)
}

// optional .robosense.perception.Proto_msg.RoadedgePosition roadedge_id = 3;
inline bool RoadEdge::has_roadedge_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoadEdge::set_has_roadedge_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoadEdge::clear_has_roadedge_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoadEdge::clear_roadedge_id() {
  roadedge_id_ = 1;
  clear_has_roadedge_id();
}
inline ::robosense::perception::Proto_msg::RoadedgePosition RoadEdge::roadedge_id() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.RoadEdge.roadedge_id)
  return static_cast< ::robosense::perception::Proto_msg::RoadedgePosition >(roadedge_id_);
}
inline void RoadEdge::set_roadedge_id(::robosense::perception::Proto_msg::RoadedgePosition value) {
  assert(::robosense::perception::Proto_msg::RoadedgePosition_IsValid(value));
  set_has_roadedge_id();
  roadedge_id_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.RoadEdge.roadedge_id)
}

// optional .robosense.perception.Proto_msg.Curve curve = 4;
inline bool RoadEdge::has_curve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadEdge::set_has_curve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadEdge::clear_has_curve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadEdge::clear_curve() {
  if (curve_ != NULL) curve_->Clear();
  clear_has_curve();
}
inline const ::robosense::perception::Proto_msg::Curve& RoadEdge::_internal_curve() const {
  return *curve_;
}
inline const ::robosense::perception::Proto_msg::Curve& RoadEdge::curve() const {
  const ::robosense::perception::Proto_msg::Curve* p = curve_;
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.RoadEdge.curve)
  return p != NULL ? *p : *reinterpret_cast<const ::robosense::perception::Proto_msg::Curve*>(
      &::robosense::perception::Proto_msg::_Curve_default_instance_);
}
inline ::robosense::perception::Proto_msg::Curve* RoadEdge::release_curve() {
  // @@protoc_insertion_point(field_release:robosense.perception.Proto_msg.RoadEdge.curve)
  clear_has_curve();
  ::robosense::perception::Proto_msg::Curve* temp = curve_;
  curve_ = NULL;
  return temp;
}
inline ::robosense::perception::Proto_msg::Curve* RoadEdge::mutable_curve() {
  set_has_curve();
  if (curve_ == NULL) {
    auto* p = CreateMaybeMessage<::robosense::perception::Proto_msg::Curve>(GetArenaNoVirtual());
    curve_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.RoadEdge.curve)
  return curve_;
}
inline void RoadEdge::set_allocated_curve(::robosense::perception::Proto_msg::Curve* curve) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete curve_;
  }
  if (curve) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      curve = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, curve, submessage_arena);
    }
    set_has_curve();
  } else {
    clear_has_curve();
  }
  curve_ = curve;
  // @@protoc_insertion_point(field_set_allocated:robosense.perception.Proto_msg.RoadEdge.curve)
}

// optional float confidence = 5;
inline bool RoadEdge::has_confidence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoadEdge::set_has_confidence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoadEdge::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoadEdge::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float RoadEdge::confidence() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.RoadEdge.confidence)
  return confidence_;
}
inline void RoadEdge::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.RoadEdge.confidence)
}

// -------------------------------------------------------------------

// RoadEdges

// optional double timestamp = 1;
inline bool RoadEdges::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadEdges::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadEdges::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadEdges::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double RoadEdges::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.RoadEdges.timestamp)
  return timestamp_;
}
inline void RoadEdges::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.RoadEdges.timestamp)
}

// repeated .robosense.perception.Proto_msg.RoadEdge roadedges = 2;
inline int RoadEdges::roadedges_size() const {
  return roadedges_.size();
}
inline void RoadEdges::clear_roadedges() {
  roadedges_.Clear();
}
inline ::robosense::perception::Proto_msg::RoadEdge* RoadEdges::mutable_roadedges(int index) {
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.RoadEdges.roadedges)
  return roadedges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::RoadEdge >*
RoadEdges::mutable_roadedges() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.RoadEdges.roadedges)
  return &roadedges_;
}
inline const ::robosense::perception::Proto_msg::RoadEdge& RoadEdges::roadedges(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.RoadEdges.roadedges)
  return roadedges_.Get(index);
}
inline ::robosense::perception::Proto_msg::RoadEdge* RoadEdges::add_roadedges() {
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.RoadEdges.roadedges)
  return roadedges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::RoadEdge >&
RoadEdges::roadedges() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.RoadEdges.roadedges)
  return roadedges_;
}

// -------------------------------------------------------------------

// PointCloud

// optional double timestamp = 1;
inline bool PointCloud::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCloud::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCloud::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCloud::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double PointCloud::timestamp() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointCloud.timestamp)
  return timestamp_;
}
inline void PointCloud::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.PointCloud.timestamp)
}

// repeated .robosense.perception.Proto_msg.PointXYZITL point = 2;
inline int PointCloud::point_size() const {
  return point_.size();
}
inline void PointCloud::clear_point() {
  point_.Clear();
}
inline ::robosense::perception::Proto_msg::PointXYZITL* PointCloud::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:robosense.perception.Proto_msg.PointCloud.point)
  return point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::PointXYZITL >*
PointCloud::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:robosense.perception.Proto_msg.PointCloud.point)
  return &point_;
}
inline const ::robosense::perception::Proto_msg::PointXYZITL& PointCloud::point(int index) const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.PointCloud.point)
  return point_.Get(index);
}
inline ::robosense::perception::Proto_msg::PointXYZITL* PointCloud::add_point() {
  // @@protoc_insertion_point(field_add:robosense.perception.Proto_msg.PointCloud.point)
  return point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robosense::perception::Proto_msg::PointXYZITL >&
PointCloud::point() const {
  // @@protoc_insertion_point(field_list:robosense.perception.Proto_msg.PointCloud.point)
  return point_;
}

// -------------------------------------------------------------------

// MsgHeader

// optional double msgTimestamps = 1;
inline bool MsgHeader::has_msgtimestamps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHeader::set_has_msgtimestamps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHeader::clear_has_msgtimestamps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHeader::clear_msgtimestamps() {
  msgtimestamps_ = 0;
  clear_has_msgtimestamps();
}
inline double MsgHeader::msgtimestamps() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgTimestamps)
  return msgtimestamps_;
}
inline void MsgHeader::set_msgtimestamps(double value) {
  set_has_msgtimestamps();
  msgtimestamps_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgTimestamps)
}

// optional uint32 msgVersion = 2;
inline bool MsgHeader::has_msgversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHeader::set_has_msgversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHeader::clear_has_msgversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHeader::clear_msgversion() {
  msgversion_ = 0u;
  clear_has_msgversion();
}
inline ::google::protobuf::uint32 MsgHeader::msgversion() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgVersion)
  return msgversion_;
}
inline void MsgHeader::set_msgversion(::google::protobuf::uint32 value) {
  set_has_msgversion();
  msgversion_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgVersion)
}

// optional uint32 msgType = 3;
inline bool MsgHeader::has_msgtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgHeader::set_has_msgtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgHeader::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgHeader::clear_msgtype() {
  msgtype_ = 0u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 MsgHeader::msgtype() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgType)
  return msgtype_;
}
inline void MsgHeader::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgType)
}

// optional uint32 deviceId = 4;
inline bool MsgHeader::has_deviceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgHeader::set_has_deviceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgHeader::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgHeader::clear_deviceid() {
  deviceid_ = 0u;
  clear_has_deviceid();
}
inline ::google::protobuf::uint32 MsgHeader::deviceid() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.deviceId)
  return deviceid_;
}
inline void MsgHeader::set_deviceid(::google::protobuf::uint32 value) {
  set_has_deviceid();
  deviceid_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.deviceId)
}

// optional uint32 msgFrameId = 5;
inline bool MsgHeader::has_msgframeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgHeader::set_has_msgframeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgHeader::clear_has_msgframeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgHeader::clear_msgframeid() {
  msgframeid_ = 0u;
  clear_has_msgframeid();
}
inline ::google::protobuf::uint32 MsgHeader::msgframeid() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgFrameId)
  return msgframeid_;
}
inline void MsgHeader::set_msgframeid(::google::protobuf::uint32 value) {
  set_has_msgframeid();
  msgframeid_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgFrameId)
}

// optional uint32 msgTotalCnt = 6;
inline bool MsgHeader::has_msgtotalcnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgHeader::set_has_msgtotalcnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgHeader::clear_has_msgtotalcnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgHeader::clear_msgtotalcnt() {
  msgtotalcnt_ = 0u;
  clear_has_msgtotalcnt();
}
inline ::google::protobuf::uint32 MsgHeader::msgtotalcnt() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgTotalCnt)
  return msgtotalcnt_;
}
inline void MsgHeader::set_msgtotalcnt(::google::protobuf::uint32 value) {
  set_has_msgtotalcnt();
  msgtotalcnt_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgTotalCnt)
}

// optional uint32 msgLocalCnt = 7;
inline bool MsgHeader::has_msglocalcnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgHeader::set_has_msglocalcnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgHeader::clear_has_msglocalcnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgHeader::clear_msglocalcnt() {
  msglocalcnt_ = 0u;
  clear_has_msglocalcnt();
}
inline ::google::protobuf::uint32 MsgHeader::msglocalcnt() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgLocalCnt)
  return msglocalcnt_;
}
inline void MsgHeader::set_msglocalcnt(::google::protobuf::uint32 value) {
  set_has_msglocalcnt();
  msglocalcnt_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgLocalCnt)
}

// optional uint32 msgLocalLen = 8;
inline bool MsgHeader::has_msglocallen() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgHeader::set_has_msglocallen() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgHeader::clear_has_msglocallen() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgHeader::clear_msglocallen() {
  msglocallen_ = 0u;
  clear_has_msglocallen();
}
inline ::google::protobuf::uint32 MsgHeader::msglocallen() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgLocalLen)
  return msglocallen_;
}
inline void MsgHeader::set_msglocallen(::google::protobuf::uint32 value) {
  set_has_msglocallen();
  msglocallen_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgLocalLen)
}

// optional uint32 msgIndex = 9;
inline bool MsgHeader::has_msgindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgHeader::set_has_msgindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgHeader::clear_has_msgindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgHeader::clear_msgindex() {
  msgindex_ = 0u;
  clear_has_msgindex();
}
inline ::google::protobuf::uint32 MsgHeader::msgindex() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgIndex)
  return msgindex_;
}
inline void MsgHeader::set_msgindex(::google::protobuf::uint32 value) {
  set_has_msgindex();
  msgindex_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgIndex)
}

// optional uint32 msgTotalFragment = 10;
inline bool MsgHeader::has_msgtotalfragment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgHeader::set_has_msgtotalfragment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgHeader::clear_has_msgtotalfragment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgHeader::clear_msgtotalfragment() {
  msgtotalfragment_ = 0u;
  clear_has_msgtotalfragment();
}
inline ::google::protobuf::uint32 MsgHeader::msgtotalfragment() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgTotalFragment)
  return msgtotalfragment_;
}
inline void MsgHeader::set_msgtotalfragment(::google::protobuf::uint32 value) {
  set_has_msgtotalfragment();
  msgtotalfragment_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgTotalFragment)
}

// optional uint32 msgFragmentIndex = 11;
inline bool MsgHeader::has_msgfragmentindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgHeader::set_has_msgfragmentindex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgHeader::clear_has_msgfragmentindex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgHeader::clear_msgfragmentindex() {
  msgfragmentindex_ = 0u;
  clear_has_msgfragmentindex();
}
inline ::google::protobuf::uint32 MsgHeader::msgfragmentindex() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgFragmentIndex)
  return msgfragmentindex_;
}
inline void MsgHeader::set_msgfragmentindex(::google::protobuf::uint32 value) {
  set_has_msgfragmentindex();
  msgfragmentindex_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgFragmentIndex)
}

// optional uint32 msgRes0 = 12;
inline bool MsgHeader::has_msgres0() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgHeader::set_has_msgres0() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgHeader::clear_has_msgres0() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgHeader::clear_msgres0() {
  msgres0_ = 0u;
  clear_has_msgres0();
}
inline ::google::protobuf::uint32 MsgHeader::msgres0() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgRes0)
  return msgres0_;
}
inline void MsgHeader::set_msgres0(::google::protobuf::uint32 value) {
  set_has_msgres0();
  msgres0_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgRes0)
}

// optional uint32 msgCheck16 = 13;
inline bool MsgHeader::has_msgcheck16() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MsgHeader::set_has_msgcheck16() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MsgHeader::clear_has_msgcheck16() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MsgHeader::clear_msgcheck16() {
  msgcheck16_ = 0u;
  clear_has_msgcheck16();
}
inline ::google::protobuf::uint32 MsgHeader::msgcheck16() const {
  // @@protoc_insertion_point(field_get:robosense.perception.Proto_msg.MsgHeader.msgCheck16)
  return msgcheck16_;
}
inline void MsgHeader::set_msgcheck16(::google::protobuf::uint32 value) {
  set_has_msgcheck16();
  msgcheck16_ = value;
  // @@protoc_insertion_point(field_set:robosense.perception.Proto_msg.MsgHeader.msgCheck16)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto_msg
}  // namespace perception
}  // namespace robosense

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::robosense::perception::Proto_msg::ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::ObjectType>() {
  return ::robosense::perception::Proto_msg::ObjectType_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::MotionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::MotionType>() {
  return ::robosense::perception::Proto_msg::MotionType_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::SizeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::SizeType>() {
  return ::robosense::perception::Proto_msg::SizeType_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::ModeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::ModeType>() {
  return ::robosense::perception::Proto_msg::ModeType_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::TrackingState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::TrackingState>() {
  return ::robosense::perception::Proto_msg::TrackingState_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::AttentionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::AttentionType>() {
  return ::robosense::perception::Proto_msg::AttentionType_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::GpsType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::GpsType>() {
  return ::robosense::perception::Proto_msg::GpsType_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::FreeSpaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::FreeSpaceType>() {
  return ::robosense::perception::Proto_msg::FreeSpaceType_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::RoadedgePosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::RoadedgePosition>() {
  return ::robosense::perception::Proto_msg::RoadedgePosition_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::LanePosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::LanePosition>() {
  return ::robosense::perception::Proto_msg::LanePosition_descriptor();
}
template <> struct is_proto_enum< ::robosense::perception::Proto_msg::MeasureStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robosense::perception::Proto_msg::MeasureStatus>() {
  return ::robosense::perception::Proto_msg::MeasureStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Proto_5fmsg_2ePercept_2eproto
